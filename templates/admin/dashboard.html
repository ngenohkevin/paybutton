{{define "content"}}
<div id="auto-refresh" hx-get="/admin/api/status" hx-trigger="load, refresh" hx-target="#dashboard-content" hx-swap="innerHTML">
    <!-- Header Section -->
    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-8">
        <div class="mb-4 sm:mb-0">
            <h1 class="text-3xl lg:text-4xl font-bold text-gray-900 dark:text-white">
                <i class="fas fa-tachometer-alt mr-3 text-blue-600"></i>System Dashboard
            </h1>
            <p class="text-gray-600 dark:text-gray-300 mt-2 text-sm">Monitor your PayButton service in real-time</p>
        </div>
        <div class="flex flex-col sm:flex-row gap-3 w-full sm:w-auto">
            <button onclick="location.reload()" class="btn btn-secondary">
                <i class="fas fa-sync-alt mr-2"></i>Refresh
            </button>
            <div class="card px-4 py-2 flex items-center">
                <span class="text-sm text-gray-600 dark:text-gray-300">Auto-refresh: </span>
                <span class="text-sm font-medium text-green-600 ml-2">
                    <i class="fas fa-circle text-green-500 animate-pulse mr-1"></i>Active
                </span>
            </div>
        </div>
    </div>

    <!-- Dashboard Content -->
    <div id="dashboard-content">
        <!-- Loading state -->
        <div class="flex flex-col justify-center items-center py-16">
            <div class="loading-spinner mb-4"></div>
            <span class="text-gray-600 dark:text-gray-300 animate-pulse">Loading system status...</span>
            <div class="flex space-x-2 mt-4">
                <div class="w-2 h-2 bg-blue-600 rounded-full animate-bounce"></div>
                <div class="w-2 h-2 bg-blue-600 rounded-full animate-bounce" style="animation-delay: 0.1s;"></div>
                <div class="w-2 h-2 bg-blue-600 rounded-full animate-bounce" style="animation-delay: 0.2s;"></div>
            </div>
        </div>
    </div>
</div>

<script>
// Real-time chart updates with enhanced styling
let poolChart, gapChart, rateLimitChart;

function updateCharts(data) {
    try {
        // Address Pool Chart
        if (poolChart && data.components && data.components.address_pool) {
            const pool = data.components.address_pool;
            // Match actual JSON field names from PoolStats struct
            const available = pool.current_pool_size || 0;
            const totalGenerated = pool.total_generated || 0;
            const totalUsed = pool.total_used || 0;
            const reserved = Math.max(0, totalGenerated - available - totalUsed);
            
            poolChart.data.datasets[0].data = [available, totalUsed + reserved];
            poolChart.data.labels = [`Available (${available})`, `Used/Reserved (${totalUsed + reserved})`];
            poolChart.update('none');
        }
        
        // Gap Monitor Chart
        if (gapChart && data.components && data.components.gap_monitor) {
            const gap = data.components.gap_monitor;
            const paid = gap.paid_addresses || 0;
            const unpaid = gap.unpaid_addresses || 0;
            
            gapChart.data.datasets[0].data = [paid, unpaid];
            gapChart.data.labels = [`Paid (${paid})`, `Unpaid (${unpaid})`];
            gapChart.update('none');
        }
        
        // Rate Limiter Chart
        if (rateLimitChart && data.components && data.components.rate_limiter) {
            const rate = data.components.rate_limiter;
            const available = rate.global_tokens || 0;
            const max = rate.global_max || 100;
            const used = Math.max(0, max - available);
            
            rateLimitChart.data.datasets[0].data = [available, used];
            rateLimitChart.data.labels = [`Available (${available})`, `Used (${used})`];
            rateLimitChart.update('none');
        }
    } catch (error) {
        console.error('Error updating charts:', error);
    }
}

// Analytics update configuration (WebSocket feeds to unified polling system)
let analyticsWS = null;
let analyticsWSReconnectDelay = 1000;
let analyticsWSMaxReconnectDelay = 30000;
let analyticsPollingTimer = null;
let lastAnalyticsData = null; // Cache for WebSocket data
let useWebSocketAnalytics = true;

// Initialize analytics WebSocket connection
function initAnalyticsWebSocket() {
    // Prevent duplicate connections
    if (analyticsWS && (analyticsWS.readyState === WebSocket.OPEN || analyticsWS.readyState === WebSocket.CONNECTING)) {
        console.log('Analytics WebSocket already connected or connecting');
        return;
    }
    
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/admin/analytics`;
    
    try {
        analyticsWS = new WebSocket(wsUrl);
        
        analyticsWS.onopen = function(event) {
            console.log('Analytics WebSocket connected');
            analyticsWSReconnectDelay = 1000; // Reset reconnect delay on successful connection
            
            // Stop any polling fallback if WebSocket is now connected
            if (analyticsPollingTimer) {
                clearTimeout(analyticsPollingTimer);
                analyticsPollingTimer = null;
                console.log('Stopped polling fallback - WebSocket reconnected');
            }
        };
        
        analyticsWS.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                if (message.type === 'analytics_update') {
                    // Cache WebSocket data and trigger unified update
                    lastAnalyticsData = message.data;
                    processAnalyticsUpdate(lastAnalyticsData, 'websocket');
                }
            } catch (error) {
                console.error('Error parsing analytics WebSocket message:', error);
            }
        };
        
        analyticsWS.onclose = function(event) {
            console.log('Analytics WebSocket closed, code:', event.code);
            analyticsWS = null;
            
            // Only switch to polling on permanent failures (not temporary disconnects)
            if (event.code !== 1000 && event.code !== 1001 && analyticsWSReconnectDelay < analyticsWSMaxReconnectDelay) {
                // Attempt reconnection with exponential backoff
                setTimeout(() => {
                    if (useWebSocketAnalytics && !analyticsWS) {
                        console.log('Attempting WebSocket reconnection...');
                        initAnalyticsWebSocket();
                    }
                }, analyticsWSReconnectDelay);
                analyticsWSReconnectDelay = Math.min(analyticsWSReconnectDelay * 2, analyticsWSMaxReconnectDelay);
            } else if (useWebSocketAnalytics) {
                console.log('WebSocket permanently closed, switching to 5-second polling fallback');
                useWebSocketAnalytics = false;
                initAnalyticsPolling();
            }
        };
        
        analyticsWS.onerror = function(error) {
            console.error('Analytics WebSocket error:', error);
        };
        
    } catch (error) {
        console.error('Failed to create analytics WebSocket:', error);
        // Fallback to periodic retry
        setTimeout(() => {
            initAnalyticsWebSocket();
        }, analyticsWSReconnectDelay);
    }
}

// Unified analytics update processor
function processAnalyticsUpdate(data, source) {
    console.log(`Processing analytics update from ${source}`);
    
    // Always update the cache
    lastAnalyticsData = data;
    
    // Update the UI with the data
    updateAnalyticsWidget(data);
}

// Load initial analytics data (fallback for first load)
function loadInitialAnalytics() {
    fetch('/admin/api/dashboard-analytics')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(data => {
            processAnalyticsUpdate(data, 'initial_fetch');
        })
        .catch(error => {
            console.error('Error loading initial analytics:', error);
            // Show loading error in widget
            const activeViewersEl = document.getElementById('dashboard-active-viewers');
            if (activeViewersEl) activeViewersEl.textContent = 'Error';
        });
}

// Polling fallback as specified in analytics.md (5-second updates)
function initAnalyticsPolling() {
    // Clear any existing polling to prevent duplicates
    if (analyticsPollingTimer) {
        clearTimeout(analyticsPollingTimer);
        analyticsPollingTimer = null;
    }
    
    function pollAnalytics() {
        // Only poll if WebSocket is not active
        if (!useWebSocketAnalytics && !analyticsWS) {
            fetch('/admin/api/dashboard-analytics')
                .then(response => response.json())
                .then(data => {
                    // Double-check WebSocket hasn't reconnected during the fetch
                    if (!useWebSocketAnalytics && !analyticsWS) {
                        processAnalyticsUpdate(data, 'polling_fallback');
                    }
                    // Schedule next poll in 5 seconds (as per analytics.md requirement)
                    if (!useWebSocketAnalytics && !analyticsWS) {
                        analyticsPollingTimer = setTimeout(pollAnalytics, 5000);
                    }
                })
                .catch(error => {
                    console.error('Error polling analytics:', error);
                    // Retry with longer delay on error, but only if still in polling mode
                    if (!useWebSocketAnalytics && !analyticsWS) {
                        analyticsPollingTimer = setTimeout(pollAnalytics, 10000);
                    }
                });
        }
    }
    
    // Start polling only if WebSocket is not active
    if (!useWebSocketAnalytics && !analyticsWS) {
        pollAnalytics();
        console.log('Started 5-second analytics polling as per analytics.md spec');
    }
}

// Update analytics widget with data and smooth transitions
function updateAnalyticsWidget(data) {
    // Update KPI cards with smooth transitions
    updateElementWithTransition('dashboard-active-viewers', data.summary?.total_active || '0');
    updateElementWithTransition('dashboard-weekly-visitors', data.summary?.total_weekly || '0');
    updateElementWithTransition('dashboard-active-sites', data.summary?.active_sites || '0');
    
    // Update timestamp
    const timestampEl = document.getElementById('analytics-timestamp');
    if (timestampEl) {
        timestampEl.textContent = new Date().toLocaleTimeString();
    }
    
    // Update site breakdown table
    updateSiteBreakdownTable(data.top_sites || []);
}

// Helper function to update elements with smooth transitions to prevent flickering
function updateElementWithTransition(elementId, newValue) {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    const currentValue = element.textContent;
    if (currentValue !== newValue.toString()) {
        // Add a subtle fade effect to indicate the change
        element.style.transition = 'opacity 0.3s ease';
        element.style.opacity = '0.7';
        
        setTimeout(() => {
            element.textContent = newValue;
            element.style.opacity = '1';
        }, 150);
        
        // Remove transition after animation
        setTimeout(() => {
            element.style.transition = '';
        }, 500);
    }
}

// Update site breakdown table
function updateSiteBreakdownTable(sites) {
    const tableContainer = document.getElementById('site-breakdown-table');
    if (!tableContainer) return;
    
    // Check if we already have a table
    const existingTable = tableContainer.querySelector('table');
    
    if (sites.length === 0) {
        // Only update if not already showing empty state
        if (!tableContainer.querySelector('.fa-inbox')) {
            tableContainer.innerHTML = `
                <div class="flex items-center justify-center py-12 sm:py-8 text-gray-400">
                    <div class="text-center space-y-3 sm:space-y-2">
                        <i class="fas fa-inbox text-4xl text-gray-600"></i>
                        <p class="text-base sm:text-sm font-semibold text-gray-300">No active sites</p>
                        <p class="text-sm sm:text-xs text-gray-400">Analytics data will appear here when sites are active</p>
                    </div>
                </div>
            `;
        }
        return;
    }
    
    // If we have an existing table, update values instead of recreating
    if (existingTable) {
        const tbody = existingTable.querySelector('tbody');
        const existingRows = tbody.querySelectorAll('tr');
        
        // Update existing rows or add new ones
        sites.forEach((site, index) => {
            if (existingRows[index]) {
                // Update existing row
                const row = existingRows[index];
                const nameEl = row.querySelector('.site-name');
                const activeEl = row.querySelector('.site-active');
                const weeklyEl = row.querySelector('.site-weekly');
                
                if (nameEl) nameEl.textContent = site.name || 'Unknown';
                if (activeEl) activeEl.textContent = site.active || 0;
                if (weeklyEl) weeklyEl.textContent = site.weekly || 0;
            } else {
                // Add new row
                const rowClass = index % 2 === 0 ? 'bg-gray-800/50' : 'bg-gray-900/50';
                const newRow = document.createElement('tr');
                newRow.className = `${rowClass} hover:bg-gray-700/50 dark:hover:bg-gray-800/50 transition-colors`;
                newRow.innerHTML = `
                    <td class="px-4 py-3">
                        <div class="flex items-center">
                            <div class="w-2 h-2 bg-green-400 rounded-full mr-3 animate-pulse"></div>
                            <span class="text-sm font-medium text-gray-200 site-name">${site.name || 'Unknown'}</span>
                        </div>
                    </td>
                    <td class="px-4 py-3 text-center">
                        <span class="text-sm font-bold text-blue-400 site-active">${site.active || 0}</span>
                    </td>
                    <td class="px-4 py-3 text-center">
                        <span class="text-sm font-bold text-purple-400 site-weekly">${site.weekly || 0}</span>
                    </td>
                `;
                tbody.appendChild(newRow);
            }
        });
        
        // Remove extra rows if sites list is shorter
        while (existingRows.length > sites.length) {
            tbody.removeChild(tbody.lastChild);
        }
    } else {
        // Create table for first time
        let tableHTML = `
            <table class="w-full">
                <thead class="bg-gray-800 dark:bg-gray-900 sticky top-0">
                    <tr class="text-xs text-gray-400 uppercase tracking-wider">
                        <th class="px-4 py-3 text-left font-semibold">Site</th>
                        <th class="px-4 py-3 text-center font-semibold">Active</th>
                        <th class="px-4 py-3 text-center font-semibold">Weekly</th>
                    </tr>
                </thead>
                <tbody class="divide-y divide-gray-700 dark:divide-gray-800">
        `;
        
        sites.forEach((site, index) => {
            const rowClass = index % 2 === 0 ? 'bg-gray-800/50' : 'bg-gray-900/50';
            tableHTML += `
                <tr class="${rowClass} hover:bg-gray-700/50 dark:hover:bg-gray-800/50 transition-colors">
                    <td class="px-4 py-3">
                        <div class="flex items-center">
                            <div class="w-2 h-2 bg-green-400 rounded-full mr-3 animate-pulse"></div>
                            <span class="text-sm font-medium text-gray-200 site-name">${site.name || 'Unknown'}</span>
                        </div>
                    </td>
                    <td class="px-4 py-3 text-center">
                        <span class="text-sm font-bold text-blue-400 site-active">${site.active || 0}</span>
                    </td>
                    <td class="px-4 py-3 text-center">
                        <span class="text-sm font-bold text-purple-400 site-weekly">${site.weekly || 0}</span>
                    </td>
                </tr>
            `;
        });
        
        tableHTML += `
                </tbody>
            </table>
        `;
        
        tableContainer.innerHTML = tableHTML;
    }
}

// Refresh site analytics manually (just load fresh data, don't disrupt WebSocket)
function refreshSiteAnalytics() {
    const btn = event.target.closest('button');
    if (btn) {
        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i><span>Refreshing...</span>';
    }
    
    // Load fresh data immediately without disrupting WebSocket connection
    loadInitialAnalytics();
    
    if (btn) {
        setTimeout(() => {
            btn.disabled = false;
            btn.innerHTML = '<i class="fas fa-sync-alt mr-2"></i><span>Refresh</span>';
        }, 1000);
    }
}

// Alpine.js component for analytics widget
document.addEventListener('alpine:init', () => {
    Alpine.data('analyticsWidget', () => ({
        // State
        activeViewers: 0,
        weeklyVisitors: 0,
        activeSites: 0,
        sites: [],
        lastUpdate: null,
        isConnected: false,
        connectionStable: false,
        
        // WebSocket
        ws: null,
        reconnectDelay: 1000,
        maxReconnectDelay: 30000,
        reconnectTimer: null,
        
        // Ping/Pong heartbeat
        heartbeatInterval: null,
        heartbeatTimer: null,
        pingInterval: 30000, // 30 seconds
        pongTimeout: 10000, // 10 seconds to wait for pong
        lastPongTime: null,
        
        // Connection state management
        connectionAttempts: 0,
        maxConnectionAttempts: 5,
        lastConnectionTime: null,
        stableConnectionDuration: 60000, // 1 minute for stable connection
        
        init() {
            console.log('Initializing Alpine analytics widget');
            // Prevent duplicate initialization
            if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
                return;
            }
            
            // Always load initial data first
            this.loadInitialData();
            
            // Try to connect WebSocket, but don't block on it
            setTimeout(() => {
                this.connect();
            }, 100);
            
            // Setup periodic fallback polling in case WebSocket fails
            this.startFallbackPolling();
            
            // Setup cleanup on page unload
            window.addEventListener('beforeunload', () => {
                this.cleanup();
            });
        },
        
        startFallbackPolling() {
            // Poll every 10 seconds as a fallback if WebSocket isn't working
            const fallbackPoll = () => {
                // Only poll if WebSocket isn't connected or stable
                if (!this.isConnected || !this.connectionStable) {
                    this.loadInitialData();
                }
                setTimeout(fallbackPoll, 10000);
            };
            
            // Start fallback polling after initial WebSocket attempt
            setTimeout(fallbackPoll, 5000);
        },
        
        connect() {
            // Prevent duplicate connections
            if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
                console.log('Alpine WebSocket already connected or connecting');
                return;
            }
            
            // Rate limiting - don't reconnect too frequently
            const now = Date.now();
            if (this.lastConnectionTime && (now - this.lastConnectionTime) < 5000) {
                console.log('Alpine WebSocket connection rate limited, waiting...');
                setTimeout(() => this.connect(), 5000);
                return;
            }
            
            this.lastConnectionTime = now;
            this.connectionAttempts++;
            
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/admin/analytics`;
            
            try {
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('Alpine WebSocket connected');
                    this.isConnected = true;
                    this.connectionStable = false;
                    this.connectionAttempts = 0;
                    this.reconnectDelay = 1000;
                    this.lastPongTime = Date.now();
                    
                    // Start heartbeat after connection is established
                    this.startHeartbeat();
                    
                    // Mark connection as stable after duration
                    setTimeout(() => {
                        if (this.isConnected) {
                            this.connectionStable = true;
                            console.log('Alpine WebSocket connection stabilized');
                        }
                    }, this.stableConnectionDuration);
                };
                
                this.ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        
                        // Handle pong responses
                        if (message.type === 'pong') {
                            this.lastPongTime = Date.now();
                            if (this.heartbeatTimer) {
                                clearTimeout(this.heartbeatTimer);
                                this.heartbeatTimer = null;
                            }
                            return;
                        }
                        
                        // Handle analytics updates
                        if (message.type === 'analytics_update') {
                            this.updateData(message.data);
                        }
                    } catch (error) {
                        console.error('Error parsing message:', error);
                    }
                };
                
                this.ws.onclose = (event) => {
                    console.log('Alpine WebSocket closed:', event.code, event.reason);
                    this.cleanup();
                    
                    // Only reconnect on unexpected closures and if not at max attempts
                    if (this.shouldReconnect(event.code) && this.connectionAttempts <= this.maxConnectionAttempts) {
                        this.scheduleReconnect();
                    } else if (this.connectionAttempts > this.maxConnectionAttempts) {
                        console.log('Alpine WebSocket max reconnection attempts reached');
                    }
                };
                
                this.ws.onerror = (error) => {
                    console.error('Alpine WebSocket error:', error);
                };
                
            } catch (error) {
                console.error('Failed to create WebSocket:', error);
                if (this.connectionAttempts <= this.maxConnectionAttempts) {
                    this.scheduleReconnect();
                }
            }
        },
        
        shouldReconnect(closeCode) {
            // Don't reconnect on normal closure or going away
            if (closeCode === 1000 || closeCode === 1001) return false;
            
            // Don't reconnect if connection was never stable and we're getting consistent failures
            if (!this.connectionStable && closeCode === 1005 && this.connectionAttempts >= 3) {
                console.log('Alpine WebSocket unstable connection, reducing reconnection attempts');
                return false;
            }
            
            return true;
        },
        
        startHeartbeat() {
            // Clear any existing heartbeat
            this.stopHeartbeat();
            
            this.heartbeatInterval = setInterval(() => {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    // Send ping
                    this.ws.send(JSON.stringify({ type: 'ping' }));
                    
                    // Set timeout for pong response
                    this.heartbeatTimer = setTimeout(() => {
                        console.log('Alpine WebSocket pong timeout, connection may be dead');
                        if (this.ws) {
                            this.ws.close(1000, 'Pong timeout');
                        }
                    }, this.pongTimeout);
                }
            }, this.pingInterval);
        },
        
        stopHeartbeat() {
            if (this.heartbeatInterval) {
                clearInterval(this.heartbeatInterval);
                this.heartbeatInterval = null;
            }
            if (this.heartbeatTimer) {
                clearTimeout(this.heartbeatTimer);
                this.heartbeatTimer = null;
            }
        },
        
        cleanup() {
            this.isConnected = false;
            this.connectionStable = false;
            this.stopHeartbeat();
            
            if (this.ws) {
                // Remove event listeners to prevent reconnection
                this.ws.onopen = null;
                this.ws.onmessage = null;
                this.ws.onclose = null;
                this.ws.onerror = null;
                
                if (this.ws.readyState === WebSocket.OPEN) {
                    this.ws.close(1000, 'Page unloading');
                }
                this.ws = null;
            }
        },
        
        scheduleReconnect() {
            if (this.reconnectTimer) return;
            
            console.log(`Alpine WebSocket scheduling reconnect in ${this.reconnectDelay}ms (attempt ${this.connectionAttempts})`);
            
            this.reconnectTimer = setTimeout(() => {
                this.reconnectTimer = null;
                this.connect();
            }, this.reconnectDelay);
            
            // Exponential backoff with jitter
            this.reconnectDelay = Math.min(
                this.reconnectDelay * 2 + Math.random() * 1000, 
                this.maxReconnectDelay
            );
        },
        
        loadInitialData() {
            fetch('/admin/api/dashboard-analytics')
                .then(response => response.json())
                .then(data => this.updateData(data))
                .catch(error => console.error('Error loading initial data:', error));
        },
        
        updateData(data) {
            // Update state with smooth transitions
            this.activeViewers = data.summary?.total_active || 0;
            this.weeklyVisitors = data.summary?.total_weekly || 0;
            this.activeSites = data.summary?.active_sites || 0;
            this.sites = data.top_sites || [];
            this.lastUpdate = new Date();
        },
        
        refresh() {
            this.loadInitialData();
        },
        
        formatTime(date) {
            if (!date) return '--:--:--';
            return date.toLocaleTimeString();
        }
    }));
});

// Track if analytics has been initialized
let analyticsInitialized = false;

// Listen for HTMX updates
document.body.addEventListener('htmx:afterSwap', function(event) {
    if (event.target.id === 'dashboard-content') {
        // Re-initialize charts after content update and load data
        setTimeout(() => {
            initializeCharts();
            
            // Don't initialize old WebSocket system if Alpine is available
            // Alpine.js will handle the analytics widget independently
            // Fetch and update chart data after a short delay to ensure DOM is ready
            setTimeout(() => {
                fetch('/admin/status')
                    .then(response => response.json())
                    .then(data => {
                        updateCharts(data);
                    })
                    .catch(error => {
                        console.error('Error fetching initial chart data:', error);
                    });
            }, 200);
        }, 100);
    }
});

function getChartTheme() {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    return {
        backgroundColor: isDark ? '#1e293b' : '#ffffff',
        borderColor: isDark ? '#334155' : '#e2e8f0',
        textColor: isDark ? '#f8fafc' : '#1e293b',
        gridColor: isDark ? '#334155' : '#f1f5f9'
    };
}

function initializeCharts() {
    const theme = getChartTheme();
    
    // Destroy existing charts if they exist
    if (poolChart) {
        poolChart.destroy();
        poolChart = null;
    }
    if (gapChart) {
        gapChart.destroy();
        gapChart = null;
    }
    if (rateLimitChart) {
        rateLimitChart.destroy();
        rateLimitChart = null;
    }
    
    // Common chart options
    const commonOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                position: 'bottom',
                labels: {
                    color: theme.textColor,
                    padding: 20,
                    usePointStyle: true,
                    font: {
                        size: 12,
                        family: 'Inter'
                    }
                }
            },
            tooltip: {
                backgroundColor: theme.backgroundColor,
                titleColor: theme.textColor,
                bodyColor: theme.textColor,
                borderColor: theme.borderColor,
                borderWidth: 1,
                cornerRadius: 8,
                padding: 12,
                displayColors: true,
                titleFont: {
                    family: 'Inter',
                    size: 14,
                    weight: 'bold'
                },
                bodyFont: {
                    family: 'Inter',
                    size: 13
                }
            }
        },
        animation: {
            animateScale: true,
            animateRotate: true,
            duration: 800,
            easing: 'easeInOutQuart'
        }
    };

    // Initialize Address Pool Chart
    const poolCtx = document.getElementById('poolChart');
    if (poolCtx) {
        poolChart = new Chart(poolCtx, {
            type: 'doughnut',
            data: {
                labels: ['Available', 'Used/Reserved'],
                datasets: [{
                    data: [0, 0],
                    backgroundColor: ['#10B981', '#EF4444'],
                    borderWidth: 3,
                    borderColor: theme.backgroundColor,
                    hoverBackgroundColor: ['#059669', '#DC2626'],
                    hoverBorderWidth: 4,
                    cutout: '60%'
                }]
            },
            options: commonOptions
        });
    }
    
    // Initialize Gap Monitor Chart
    const gapCtx = document.getElementById('gapChart');
    if (gapCtx) {
        gapChart = new Chart(gapCtx, {
            type: 'doughnut',
            data: {
                labels: ['Paid', 'Unpaid'],
                datasets: [{
                    data: [0, 0],
                    backgroundColor: ['#10B981', '#F59E0B'],
                    borderWidth: 3,
                    borderColor: theme.backgroundColor,
                    hoverBackgroundColor: ['#059669', '#D97706'],
                    hoverBorderWidth: 4,
                    cutout: '60%'
                }]
            },
            options: commonOptions
        });
    }
    
    // Initialize Rate Limiter Chart
    const rateCtx = document.getElementById('rateLimitChart');
    if (rateCtx) {
        rateLimitChart = new Chart(rateCtx, {
            type: 'doughnut',
            data: {
                labels: ['Available Tokens', 'Used Tokens'],
                datasets: [{
                    data: [0, 0],
                    backgroundColor: ['#3B82F6', '#9CA3AF'],
                    borderWidth: 3,
                    borderColor: theme.backgroundColor,
                    hoverBackgroundColor: ['#2563EB', '#6B7280'],
                    hoverBorderWidth: 4,
                    cutout: '60%'
                }]
            },
            options: commonOptions
        });
    }
}

// Re-initialize charts on theme change
document.addEventListener('themechange', function() {
    setTimeout(initializeCharts, 100);
});

// Update charts periodically with real data
let chartUpdateInterval;

function startChartUpdates() {
    // Clear any existing interval
    if (chartUpdateInterval) {
        clearInterval(chartUpdateInterval);
    }
    
    // Update charts every 5 seconds
    chartUpdateInterval = setInterval(() => {
        if (poolChart || gapChart || rateLimitChart) {
            fetch('/admin/status')
                .then(response => response.json())
                .then(data => {
                    updateCharts(data);
                })
                .catch(error => {
                    console.error('Error updating charts:', error);
                });
        }
    }, 5000);
}

// Start chart updates when dashboard loads
document.body.addEventListener('htmx:afterSettle', function(event) {
    if (event.target.id === 'dashboard-content') {
        // Small delay to ensure charts are initialized
        setTimeout(() => {
            startChartUpdates();
            // Initial update
            fetch('/admin/status')
                .then(response => response.json())
                .then(data => {
                    updateCharts(data);
                })
                .catch(error => {
                    console.error('Error fetching chart data:', error);
                });
        }, 300);
    }
});

// Clean up interval when navigating away
window.addEventListener('beforeunload', () => {
    if (chartUpdateInterval) {
        clearInterval(chartUpdateInterval);
    }
});

// Add custom styles for enhanced UI
const customStyles = `
<style>
/* Custom scrollbar styling */
.custom-scrollbar::-webkit-scrollbar {
    width: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
    background: rgb(243 244 246);
    border-radius: 3px;
}

.dark .custom-scrollbar::-webkit-scrollbar-track {
    background: rgb(55 65 81);
}

.custom-scrollbar::-webkit-scrollbar-thumb {
    background: linear-gradient(45deg, rgb(59 130 246), rgb(37 99 235));
    border-radius: 3px;
    transition: background 0.3s ease;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(45deg, rgb(37 99 235), rgb(29 78 216));
}

/* Enhanced hover animations */
.hover\\:scale-102:hover {
    transform: scale(1.02);
}

/* Pulse animation for live indicators */
@keyframes pulse-green {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

.animate-pulse-green {
    animation: pulse-green 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Gradient text animation */
@keyframes gradient-x {
    0%, 100% {
        background-size: 200% 200%;
        background-position: left center;
    }
    50% {
        background-size: 200% 200%;
        background-position: right center;
    }
}

.animate-gradient-x {
    animation: gradient-x 3s ease infinite;
}

/* Enhanced card shadows */
.card-shadow {
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06), 
                0 0 0 1px rgba(0, 0, 0, 0.05);
}

.dark .card-shadow {
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2), 
                0 0 0 1px rgba(255, 255, 255, 0.05);
}

/* Loading shimmer effect */
@keyframes shimmer {
    0% {
        background-position: -468px 0;
    }
    100% {
        background-position: 468px 0;
    }
}

.animate-shimmer {
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 37%, #f0f0f0 63%);
    background-size: 400% 100%;
    animation: shimmer 1.4s ease-in-out infinite;
}

.dark .animate-shimmer {
    background: linear-gradient(90deg, #374151 25%, #4b5563 37%, #374151 63%);
    background-size: 400% 100%;
}

/* Responsive utilities */
@media (max-width: 768px) {
    .text-responsive-lg {
        font-size: 1.25rem !important;
        line-height: 1.75rem !important;
    }
    
    .text-responsive-xl {
        font-size: 1.5rem !important;
        line-height: 2rem !important;
    }
}
</style>
`;

// Insert styles into head
document.head.insertAdjacentHTML('beforeend', customStyles);

// Session Analytics Functions
let sessionUpdateInterval;

function updateSessionStats() {
    fetch('/admin/api/dashboard-sessions')
        .then(response => response.json())
        .then(data => {
            // Update dashboard session metrics
            document.getElementById('dashboard-active-sessions').textContent = data.active_sessions || 0;
            document.getElementById('dashboard-websocket-count').textContent = data.websocket_count || 0;
            document.getElementById('dashboard-payment-rate').textContent = data.payment_rate ? data.payment_rate.toFixed(1) + '%' : '0%';
            document.getElementById('dashboard-paid-amount').textContent = '$' + (data.paid_amount ? data.paid_amount.toFixed(2) : '0.00');
        })
        .catch(error => {
            console.error('Error updating session stats:', error);
            // Set fallback values on error
            document.getElementById('dashboard-active-sessions').textContent = '0';
            document.getElementById('dashboard-websocket-count').textContent = '0';
            document.getElementById('dashboard-payment-rate').textContent = '0%';
            document.getElementById('dashboard-paid-amount').textContent = '$0.00';
        });
}

function startSessionUpdates() {
    // Clear any existing interval
    if (sessionUpdateInterval) {
        clearInterval(sessionUpdateInterval);
    }
    
    // Update session stats every 10 seconds
    sessionUpdateInterval = setInterval(updateSessionStats, 10000);
    
    // Initial update
    updateSessionStats();
}

// Site Analytics Functions (now using WebSocket instead of polling)

function updateSiteBreakdownTable(sites) {
    const tableEl = document.getElementById('site-breakdown-table');
    if (!tableEl) return;
    
    // Update timestamp
    const timestampEl = document.getElementById('analytics-timestamp');
    if (timestampEl) {
        timestampEl.textContent = new Date().toLocaleTimeString();
    }
    
    if (!sites || sites.length === 0) {
        tableEl.innerHTML = `
            <div class="flex flex-col items-center justify-center py-16 sm:py-12 px-4 text-gray-400">
                <div class="w-20 h-20 sm:w-16 sm:h-16 bg-gray-700 dark:bg-gray-800 rounded-full flex items-center justify-center mb-6 sm:mb-4 border border-gray-600">
                    <i class="fas fa-globe text-3xl sm:text-2xl text-gray-500"></i>
                </div>
                <p class="text-xl sm:text-lg font-semibold mb-3 sm:mb-2 text-gray-300">No Active Sites</p>
                <p class="text-base sm:text-sm text-center max-w-sm px-4 text-gray-400">
                    Sites will appear here when visitors connect to your analytics service
                </p>
            </div>
        `;
        return;
    }
    
    // Build responsive card layout for mobile and table for desktop
    let contentHTML = `
        <!-- Mobile Card Layout (Hidden on desktop) -->
        <div class="block lg:hidden space-y-4 p-4 sm:p-6">
    `;
    
    sites.forEach((site, index) => {
        const statusColor = site.active > 0 ? 'bg-green-400' : 'bg-gray-500';
        const statusText = site.active > 0 ? 'Live' : 'Idle';
        const activeColor = site.active > 0 ? 'text-emerald-300' : 'text-gray-400';
        const bgGradient = site.active > 0 
            ? 'bg-gradient-to-br from-emerald-800 to-emerald-900 border-emerald-600' 
            : 'bg-gradient-to-br from-gray-700 to-gray-800 border-gray-600';
        
        contentHTML += `
            <div class="relative ${bgGradient} border rounded-2xl p-6 transition-all duration-200 hover:shadow-2xl transform hover:scale-102 shadow-xl">
                <div class="absolute top-4 right-4">
                    <div class="flex items-center space-x-2 px-3 py-1 bg-black bg-opacity-20 rounded-full border border-opacity-30 ${site.active > 0 ? 'border-green-400' : 'border-gray-500'}">
                        <div class="w-2 h-2 ${statusColor} rounded-full ${site.active > 0 ? 'animate-pulse' : ''} shadow-sm"></div>
                        <span class="text-xs font-bold text-white">${statusText}</span>
                    </div>
                </div>
                <div class="space-y-5">
                    <div class="flex items-center space-x-4">
                        <div class="flex-shrink-0 w-14 h-14 bg-gradient-to-br from-blue-600 to-blue-700 rounded-2xl flex items-center justify-center shadow-lg border border-blue-500 border-opacity-30">
                            <i class="fas fa-globe text-blue-200 text-lg"></i>
                        </div>
                        <div class="flex-1 min-w-0 pr-12">
                            <p class="text-lg font-black text-white truncate mb-1" title="${site.name}">
                                ${site.name}
                            </p>
                            <p class="text-sm text-gray-300 font-semibold">Site #${index + 1}</p>
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <div class="text-center bg-gray-800 bg-opacity-60 rounded-xl p-4 shadow-inner border border-gray-600 border-opacity-30">
                            <div class="text-3xl font-black ${activeColor} mb-1">${site.active}</div>
                            <div class="text-xs text-gray-300 font-bold uppercase tracking-wide">Active Now</div>
                            ${site.active > 0 ? '<div class="w-2 h-2 bg-green-400 rounded-full animate-pulse mx-auto mt-2 shadow-sm"></div>' : ''}
                        </div>
                        <div class="text-center bg-gray-800 bg-opacity-60 rounded-xl p-4 shadow-inner border border-gray-600 border-opacity-30">
                            <div class="text-3xl font-black text-indigo-300 mb-1">${site.weekly || 0}</div>
                            <div class="text-xs text-gray-300 font-bold uppercase tracking-wide">This Week</div>
                            <div class="w-2 h-2 bg-indigo-400 rounded-full mx-auto mt-2"></div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    });
    
    contentHTML += `
        </div>
        
        <!-- Desktop Table Layout (Hidden on mobile/tablet) -->
        <div class="hidden lg:block">
            <table class="w-full">
                <thead class="bg-gradient-to-r from-gray-100 to-gray-50 dark:from-gray-700 dark:to-gray-800 border-b border-gray-200 dark:border-gray-600">
                    <tr>
                        <th class="px-6 py-4 text-left text-sm font-bold text-gray-700 dark:text-gray-300 uppercase tracking-wider">
                            <div class="flex items-center space-x-2">
                                <i class="fas fa-globe text-blue-500"></i>
                                <span>Site</span>
                            </div>
                        </th>
                        <th class="px-6 py-4 text-center text-sm font-bold text-gray-700 dark:text-gray-300 uppercase tracking-wider">
                            <div class="flex items-center justify-center space-x-2">
                                <i class="fas fa-eye text-emerald-500"></i>
                                <span>Active</span>
                            </div>
                        </th>
                        <th class="px-6 py-4 text-center text-sm font-bold text-gray-700 dark:text-gray-300 uppercase tracking-wider">
                            <div class="flex items-center justify-center space-x-2">
                                <i class="fas fa-calendar-week text-indigo-500"></i>
                                <span>Weekly</span>
                            </div>
                        </th>
                        <th class="px-6 py-4 text-center text-sm font-bold text-gray-700 dark:text-gray-300 uppercase tracking-wider">
                            <div class="flex items-center justify-center space-x-2">
                                <i class="fas fa-signal text-teal-500"></i>
                                <span>Status</span>
                            </div>
                        </th>
                    </tr>
                </thead>
                <tbody class="divide-y divide-gray-200 dark:divide-gray-700">
    `;
    
    sites.forEach((site, index) => {
        const statusColor = site.active > 0 
            ? 'bg-green-500 text-white' 
            : 'bg-gray-400 dark:bg-gray-600 text-white';
        const statusText = site.active > 0 ? 'Live' : 'Idle';
        const statusIcon = site.active > 0 ? 'fas fa-broadcast-tower' : 'fas fa-pause';
        const activeColor = site.active > 0 ? 'text-emerald-600 dark:text-emerald-400' : 'text-gray-500';
        const rowBg = site.active > 0 
            ? 'bg-green-50/30 dark:bg-green-900/10 hover:bg-green-50 dark:hover:bg-green-900/20' 
            : 'bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700';
        
        contentHTML += `
            <tr class="${rowBg} transition-all duration-200 hover:shadow-sm">
                <td class="px-6 py-4">
                    <div class="flex items-center space-x-4">
                        <div class="flex-shrink-0 w-10 h-10 bg-gradient-to-br from-blue-500 to-blue-600 rounded-lg flex items-center justify-center shadow-sm">
                            <i class="fas fa-globe text-white text-sm"></i>
                        </div>
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center space-x-2">
                                <p class="text-sm font-bold text-gray-900 dark:text-white truncate max-w-48" title="${site.name}">
                                    ${site.name}
                                </p>
                                ${site.active > 0 ? '<div class="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>' : ''}
                            </div>
                            <p class="text-xs text-gray-500 dark:text-gray-400 font-medium">
                                Site #${index + 1}
                            </p>
                        </div>
                    </div>
                </td>
                <td class="px-6 py-4 text-center">
                    <div class="flex flex-col items-center space-y-1">
                        <span class="text-2xl font-black ${activeColor}">${site.active}</span>
                        <span class="text-xs text-gray-500 dark:text-gray-400 font-medium">viewers</span>
                    </div>
                </td>
                <td class="px-6 py-4 text-center">
                    <div class="flex flex-col items-center space-y-1">
                        <span class="text-xl font-bold text-indigo-600 dark:text-indigo-400">${site.weekly || 0}</span>
                        <span class="text-xs text-gray-500 dark:text-gray-400 font-medium">total</span>
                    </div>
                </td>
                <td class="px-6 py-4 text-center">
                    <span class="inline-flex items-center px-3 py-2 rounded-full text-sm font-bold ${statusColor} shadow-sm">
                        <i class="${statusIcon} mr-2 text-xs ${site.active > 0 ? 'animate-pulse' : ''}"></i>
                        ${statusText}
                    </span>
                </td>
            </tr>
        `;
    });
    
    contentHTML += `
                </tbody>
            </table>
        </div>
    `;
    
    tableEl.innerHTML = contentHTML;
    
    // Add smooth entrance animations
    setTimeout(() => {
        const cards = tableEl.querySelectorAll('div[class*="hover:scale-102"], tr');
        cards.forEach((card, index) => {
            card.style.opacity = '0';
            card.style.transform = 'translateY(10px)';
            setTimeout(() => {
                card.style.transition = 'all 0.3s ease-out';
                card.style.opacity = '1';
                card.style.transform = 'translateY(0)';
            }, index * 50);
        });
    }, 10);
}

function startSiteAnalyticsUpdates() {
    // Try WebSocket first for instant updates, fallback to 5s polling as per analytics.md
    if (useWebSocketAnalytics && typeof WebSocket !== 'undefined') {
        initAnalyticsWebSocket();
    } else {
        console.log('WebSocket not available, using 5-second polling as per analytics.md');
        initAnalyticsPolling();
    }
    
    // Load initial data
    loadInitialAnalytics();
}

// Start session and site analytics updates when dashboard loads
document.body.addEventListener('htmx:afterSettle', function(event) {
    if (event.target.id === 'dashboard-content') {
        // Start session updates along with chart updates
        setTimeout(startSessionUpdates, 500);
        
        // Start site analytics updates - Initialize both old system and Alpine.js
        setTimeout(startSiteAnalyticsUpdates, 600);
        
        // Also ensure Alpine.js analytics widget loads data immediately
        setTimeout(() => {
            // Try to trigger Alpine.js data loading if available
            const analyticsWidget = document.querySelector('[x-data="analyticsWidget"]');
            if (analyticsWidget && analyticsWidget._x_dataStack) {
                const component = analyticsWidget._x_dataStack[0];
                if (component && typeof component.loadInitialData === 'function') {
                    component.loadInitialData();
                }
            }
            
            // Fallback: Load initial analytics data directly
            loadInitialAnalytics();
        }, 800);
    }
});

// Clean up intervals and WebSocket when navigating away
window.addEventListener('beforeunload', () => {
    if (sessionUpdateInterval) {
        clearInterval(sessionUpdateInterval);
    }
    if (analyticsWS) {
        analyticsWS.close();
    }
    if (analyticsPollingTimer) {
        clearTimeout(analyticsPollingTimer);
    }
});
</script>
{{end}}