{{define "content"}}
<div id="auto-refresh" hx-get="/admin/api/status" hx-trigger="load" hx-target="#dashboard-content" hx-swap="innerHTML">
    <!-- Header Section -->
    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-8">
        <div class="mb-4 sm:mb-0">
            <h1 class="text-3xl lg:text-4xl font-bold text-gray-900 dark:text-white">
                <i class="fas fa-tachometer-alt mr-3 text-blue-600"></i>System Dashboard
            </h1>
            <p class="text-gray-600 dark:text-gray-300 mt-2 text-sm">Monitor your PayButton service in real-time</p>
        </div>
        <div class="flex flex-col sm:flex-row gap-3 w-full sm:w-auto">
            <button onclick="location.reload()" class="btn btn-secondary">
                <i class="fas fa-sync-alt mr-2"></i>Refresh
            </button>
            <div class="card px-4 py-2 flex items-center">
                <span class="text-sm text-gray-600 dark:text-gray-300">Auto-refresh: </span>
                <span class="text-sm font-medium text-green-600 ml-2">
                    <i class="fas fa-circle text-green-500 animate-pulse mr-1"></i>Active
                </span>
            </div>
        </div>
    </div>

    <!-- Dashboard Content -->
    <div id="dashboard-content">
        <!-- Loading state - ANIMATIONS DISABLED for CPU optimization -->
        <div class="flex flex-col justify-center items-center py-16">
            <div class="loading-spinner mb-4"></div>
            <span class="text-gray-600 dark:text-gray-300">Loading system status...</span>
        </div>
    </div>
</div>

<script>
// CHARTS REMOVED - No chart update logic needed
function updateCharts(data) {
    console.log('Chart updates disabled - charts have been removed');
    // No charts to update
}

// Analytics update configuration (Single unified system)
let analyticsWS = null;
let analyticsWSReconnectDelay = 5000; // Increased initial delay
let analyticsWSMaxReconnectDelay = 60000; // Increased max delay
let analyticsPollingTimer = null;
let lastAnalyticsData = null; // Cache to prevent unnecessary updates
let useWebSocketAnalytics = false; // Disabled - WebSocket endpoint not implemented
let updateDebounceTimer = null; // Prevent rapid updates
let lastUpdateTime = 0; // Track last update timestamp
let wsReconnectAttempts = 0;
let maxWSReconnectAttempts = 3; // Stop after 3 failed attempts

// Initialize analytics WebSocket connection - DISABLED TO REDUCE CPU
function initAnalyticsWebSocket() {
    // WebSocket disabled - analytics endpoint not implemented
    console.log('WebSocket analytics disabled - using polling only');
    return;

    /* DISABLED - Causes excessive CPU usage from reconnection attempts
    // Prevent duplicate connections
    if (analyticsWS && (analyticsWS.readyState === WebSocket.OPEN || analyticsWS.readyState === WebSocket.CONNECTING)) {
        console.log('Analytics WebSocket already connected or connecting');
        return;
    }

    // Stop trying after max attempts
    if (wsReconnectAttempts >= maxWSReconnectAttempts) {
        console.log('Max WebSocket reconnect attempts reached, using polling only');
        useWebSocketAnalytics = false;
        return;
    }

    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/admin/analytics`;

    try {
        analyticsWS = new WebSocket(wsUrl);
        wsReconnectAttempts++;

        analyticsWS.onopen = function(event) {
            console.log('Analytics WebSocket connected');
            wsReconnectAttempts = 0; // Reset on successful connection
            analyticsWSReconnectDelay = 5000;

            // Stop any polling fallback if WebSocket is now connected
            if (analyticsPollingTimer) {
                clearTimeout(analyticsPollingTimer);
                analyticsPollingTimer = null;
                console.log('Stopped polling fallback - WebSocket reconnected');
            }
        };

        analyticsWS.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                if (message.type === 'analytics_update') {
                    // Cache WebSocket data and trigger unified update
                    lastAnalyticsData = message.data;
                    processAnalyticsUpdate(lastAnalyticsData, 'websocket');
                }
            } catch (error) {
                console.error('Error parsing analytics WebSocket message:', error);
            }
        };

        analyticsWS.onclose = function(event) {
            console.log('Analytics WebSocket closed, code:', event.code);
            analyticsWS = null;

            // Switch to polling instead of reconnecting
            console.log('WebSocket closed, using polling fallback');
            useWebSocketAnalytics = false;
            if (!analyticsPollingTimer) {
                initAnalyticsPolling();
            }
        };

        analyticsWS.onerror = function(error) {
            console.error('Analytics WebSocket error:', error);
        };

    } catch (error) {
        console.error('Failed to create analytics WebSocket:', error);
    }
    */
}

// Unified analytics update processor with debouncing
function processAnalyticsUpdate(data, source) {
    const now = Date.now();

    // Debounce: Ignore updates that come within 1 second of each other
    if (now - lastUpdateTime < 1000) {
        console.log(`Debouncing ${source} update - too soon after last update`);
        // Clear existing debounce timer
        if (updateDebounceTimer) {
            clearTimeout(updateDebounceTimer);
        }
        // Schedule update for later
        updateDebounceTimer = setTimeout(() => {
            processAnalyticsUpdate(data, source + '_debounced');
        }, 1000);
        return;
    }

    console.log(`Processing analytics update from ${source}`);
    lastUpdateTime = now;

    // Check if data actually changed before updating UI
    if (lastAnalyticsData && JSON.stringify(data) === JSON.stringify(lastAnalyticsData)) {
        console.log(`Skipping ${source} update - data unchanged`);
        return;
    }

    // Update the cache
    lastAnalyticsData = data;

    // Update the UI with the data
    updateAnalyticsWidget(data);
}

// Load initial analytics data (fallback for first load)
function loadInitialAnalytics() {
    fetch('/admin/api/dashboard-analytics')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(data => {
            processAnalyticsUpdate(data, 'initial_fetch');
        })
        .catch(error => {
            console.error('Error loading initial analytics:', error);
            // Show loading error in widget
            const activeViewersEl = document.getElementById('dashboard-active-viewers');
            if (activeViewersEl) activeViewersEl.textContent = 'Error';
        });
}

// Polling fallback with REDUCED frequency to prevent CPU overload (changed to 30s)
function initAnalyticsPolling() {
    // CRITICAL: Clear any existing polling to prevent duplicates and leaks
    if (analyticsPollingTimer !== null) {
        clearTimeout(analyticsPollingTimer);
        analyticsPollingTimer = null;
        console.log('Cleared existing analytics polling timer');
    }

    function pollAnalytics() {
        // Only poll if WebSocket is not active AND page is visible
        if (!useWebSocketAnalytics && !analyticsWS && !document.hidden) {
            fetch('/admin/api/dashboard-analytics')
                .then(response => response.json())
                .then(data => {
                    // Double-check WebSocket hasn't reconnected during the fetch
                    if (!useWebSocketAnalytics && !analyticsWS) {
                        processAnalyticsUpdate(data, 'polling_fallback');
                    }
                    // Schedule next poll in 30 seconds (REDUCED from 5s to save CPU)
                    if (!useWebSocketAnalytics && !analyticsWS && analyticsPollingTimer === null) {
                        analyticsPollingTimer = setTimeout(pollAnalytics, 30000);
                    }
                })
                .catch(error => {
                    console.error('Error polling analytics:', error);
                    // Retry with longer delay on error, but only if still in polling mode
                    if (!useWebSocketAnalytics && !analyticsWS && analyticsPollingTimer === null) {
                        analyticsPollingTimer = setTimeout(pollAnalytics, 60000);
                    }
                });
        } else if (document.hidden && analyticsPollingTimer === null) {
            // If page is hidden, check again in 60 seconds
            analyticsPollingTimer = setTimeout(pollAnalytics, 60000);
        }
    }

    // Start polling only if WebSocket is not active
    if (!useWebSocketAnalytics && !analyticsWS) {
        pollAnalytics();
        console.log('Started 30-second analytics polling (reduced from 5s to save CPU)');
    }
}

// Update analytics widget with data and smooth transitions
function updateAnalyticsWidget(data) {
    // Update KPI cards with smooth transitions
    updateElementWithTransition('dashboard-active-viewers', data.summary?.total_active || '0');
    updateElementWithTransition('dashboard-weekly-visitors', data.summary?.total_weekly || '0');
    updateElementWithTransition('dashboard-active-sites', data.summary?.active_sites || '0');
    
    // Update timestamp
    const timestampEl = document.getElementById('analytics-timestamp');
    if (timestampEl) {
        timestampEl.textContent = new Date().toLocaleTimeString();
    }
    
    // Update site breakdown table
    updateSiteBreakdownTable(data.top_sites || []);
}

// Helper function to update elements with smooth transitions to prevent flickering
function updateElementWithTransition(elementId, newValue) {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    const currentValue = element.textContent;
    if (currentValue !== newValue.toString()) {
        // Add a subtle fade effect to indicate the change
        element.style.transition = 'opacity 0.3s ease';
        element.style.opacity = '0.7';
        
        setTimeout(() => {
            element.textContent = newValue;
            element.style.opacity = '1';
        }, 150);
        
        // Remove transition after animation
        setTimeout(() => {
            element.style.transition = '';
        }, 500);
    }
}

// Update site breakdown table - OPTIMIZED to prevent flickering
function updateSiteBreakdownTable(sites) {
    const tableContainer = document.getElementById('site-breakdown-table');
    if (!tableContainer) return;

    // Check if we already have a table
    const existingTable = tableContainer.querySelector('table');

    if (!sites || sites.length === 0) {
        // Only update if not already showing empty state
        if (!tableContainer.querySelector('.fa-inbox')) {
            tableContainer.innerHTML = `
                <div class="flex items-center justify-center py-12 sm:py-8 text-gray-400">
                    <div class="text-center space-y-3 sm:space-y-2">
                        <i class="fas fa-inbox text-4xl text-gray-600"></i>
                        <p class="text-base sm:text-sm font-semibold text-gray-300">No active sites</p>
                        <p class="text-sm sm:text-xs text-gray-400">Analytics data will appear here when sites are active</p>
                    </div>
                </div>
            `;
        }
        return;
    }

    // If we have an existing table, ONLY update values - DO NOT REBUILD
    if (existingTable) {
        const tbody = existingTable.querySelector('tbody');
        const existingRows = Array.from(tbody.querySelectorAll('tr'));

        // Update existing rows
        sites.forEach((site, index) => {
            if (existingRows[index]) {
                // ONLY update text content if it changed - prevents flickering
                const row = existingRows[index];
                const nameEl = row.querySelector('.site-name');
                const activeEl = row.querySelector('.site-active');
                const weeklyEl = row.querySelector('.site-weekly');

                const newName = site.name || 'Unknown';
                const newActive = (site.active || 0).toString();
                const newWeekly = (site.weekly || 0).toString();

                if (nameEl && nameEl.textContent !== newName) {
                    nameEl.textContent = newName;
                }
                if (activeEl && activeEl.textContent !== newActive) {
                    activeEl.textContent = newActive;
                }
                if (weeklyEl && weeklyEl.textContent !== newWeekly) {
                    weeklyEl.textContent = newWeekly;
                }
            } else {
                // Add new row only if needed
                const rowClass = index % 2 === 0 ? 'bg-gray-800/50' : 'bg-gray-900/50';
                const newRow = document.createElement('tr');
                newRow.className = `${rowClass} hover:bg-gray-700/50 dark:hover:bg-gray-800/50 transition-colors`;
                newRow.innerHTML = `
                    <td class="px-4 py-3">
                        <div class="flex items-center">
                            <div class="w-2 h-2 bg-green-400 rounded-full mr-3 animate-pulse"></div>
                            <span class="text-sm font-medium text-gray-200 site-name">${site.name || 'Unknown'}</span>
                        </div>
                    </td>
                    <td class="px-4 py-3 text-center">
                        <span class="text-sm font-bold text-blue-400 site-active">${site.active || 0}</span>
                    </td>
                    <td class="px-4 py-3 text-center">
                        <span class="text-sm font-bold text-purple-400 site-weekly">${site.weekly || 0}</span>
                    </td>
                `;
                tbody.appendChild(newRow);
            }
        });

        // Remove extra rows if sites list is shorter
        while (existingRows.length > sites.length) {
            const lastRow = tbody.lastChild;
            if (lastRow) tbody.removeChild(lastRow);
            existingRows.pop();
        }
    } else {
        // Create table for first time ONLY
        let tableHTML = `
            <table class="w-full">
                <thead class="bg-gray-800 dark:bg-gray-900 sticky top-0">
                    <tr class="text-xs text-gray-400 uppercase tracking-wider">
                        <th class="px-4 py-3 text-left font-semibold">Site</th>
                        <th class="px-4 py-3 text-center font-semibold">Active</th>
                        <th class="px-4 py-3 text-center font-semibold">Weekly</th>
                    </tr>
                </thead>
                <tbody class="divide-y divide-gray-700 dark:divide-gray-800">
        `;

        sites.forEach((site, index) => {
            const rowClass = index % 2 === 0 ? 'bg-gray-800/50' : 'bg-gray-900/50';
            tableHTML += `
                <tr class="${rowClass} hover:bg-gray-700/50 dark:hover:bg-gray-800/50 transition-colors">
                    <td class="px-4 py-3">
                        <div class="flex items-center">
                            <div class="w-2 h-2 bg-green-400 rounded-full mr-3 animate-pulse"></div>
                            <span class="text-sm font-medium text-gray-200 site-name">${site.name || 'Unknown'}</span>
                        </div>
                    </td>
                    <td class="px-4 py-3 text-center">
                        <span class="text-sm font-bold text-blue-400 site-active">${site.active || 0}</span>
                    </td>
                    <td class="px-4 py-3 text-center">
                        <span class="text-sm font-bold text-purple-400 site-weekly">${site.weekly || 0}</span>
                    </td>
                </tr>
            `;
        });

        tableHTML += `
                </tbody>
            </table>
        `;

        tableContainer.innerHTML = tableHTML;
    }
}

// Refresh site analytics manually (just load fresh data, don't disrupt WebSocket)
function refreshSiteAnalytics() {
    const btn = event.target.closest('button');
    if (btn) {
        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i><span>Refreshing...</span>';
    }
    
    // Load fresh data immediately without disrupting WebSocket connection
    loadInitialAnalytics();
    
    if (btn) {
        setTimeout(() => {
            btn.disabled = false;
            btn.innerHTML = '<i class="fas fa-sync-alt mr-2"></i><span>Refresh</span>';
        }, 1000);
    }
}

// REMOVED Alpine.js duplicate analytics system - using unified WebSocket system above

// Track if analytics has been initialized
let analyticsInitialized = false;

// Listen for HTMX updates
document.body.addEventListener('htmx:afterSwap', function(event) {
    if (event.target.id === 'dashboard-content') {
        // Re-initialize charts after content update and load data
        setTimeout(() => {
            initializeCharts();
            
            // Don't initialize old WebSocket system if Alpine is available
            // Alpine.js will handle the analytics widget independently
            // Fetch and update chart data after a short delay to ensure DOM is ready
            setTimeout(() => {
                fetch('/admin/status')
                    .then(response => response.json())
                    .then(data => {
                        updateCharts(data);
                    })
                    .catch(error => {
                        console.error('Error fetching initial chart data:', error);
                    });
            }, 200);
        }, 100);
    }
});

function getChartTheme() {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    return {
        backgroundColor: isDark ? '#1e293b' : '#ffffff',
        borderColor: isDark ? '#334155' : '#e2e8f0',
        textColor: isDark ? '#f8fafc' : '#1e293b',
        gridColor: isDark ? '#334155' : '#f1f5f9'
    };
}

// CHARTS COMPLETELY REMOVED - Replaced with simple HTML to eliminate GPU usage
function initializeCharts() {
    console.log('⚠️ Chart.js REMOVED - Using simple HTML elements instead to eliminate GPU CPU usage');
    // No charts to initialize
}

// No theme change handling needed
// document.addEventListener('themechange', function() {});

// Update charts periodically with real data - REDUCED frequency to save CPU
let chartUpdateInterval = null;

function startChartUpdates() {
    // DISABLED: Chart polling disabled to eliminate CPU usage
    // Charts will only update on manual refresh
    console.log('⚠️ Chart auto-updates DISABLED - use manual refresh button to update charts');

    // chartUpdateInterval = setInterval(() => {
    //     if ((poolChart || gapChart || rateLimitChart) && !document.hidden) {
    //         fetch('/admin/status')
    //             .then(response => response.json())
    //             .then(data => updateCharts(data))
    //             .catch(error => console.error('Error updating charts:', error));
    //     }
    // }, 30000);
}

// Start chart updates when dashboard loads
document.body.addEventListener('htmx:afterSettle', function(event) {
    if (event.target.id === 'dashboard-content') {
        // Small delay to ensure charts are initialized
        setTimeout(() => {
            startChartUpdates();
            // Initial update
            fetch('/admin/status')
                .then(response => response.json())
                .then(data => {
                    updateCharts(data);
                })
                .catch(error => {
                    console.error('Error fetching chart data:', error);
                });
        }, 300);
    }
});

// Clean up interval when navigating away
window.addEventListener('beforeunload', () => {
    if (chartUpdateInterval) {
        clearInterval(chartUpdateInterval);
    }
});

// Add custom styles for enhanced UI
const customStyles = `
<style>
/* Custom scrollbar styling */
.custom-scrollbar::-webkit-scrollbar {
    width: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
    background: rgb(243 244 246);
    border-radius: 3px;
}

.dark .custom-scrollbar::-webkit-scrollbar-track {
    background: rgb(55 65 81);
}

.custom-scrollbar::-webkit-scrollbar-thumb {
    background: linear-gradient(45deg, rgb(59 130 246), rgb(37 99 235));
    border-radius: 3px;
    transition: background 0.3s ease;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(45deg, rgb(37 99 235), rgb(29 78 216));
}

/* Enhanced hover animations */
.hover\\:scale-102:hover {
    transform: scale(1.02);
}

/* DISABLE ALL ANIMATIONS TO REDUCE CPU USAGE */
* {
    animation-duration: 0s !important;
    animation-delay: 0s !important;
    transition-duration: 0s !important;
}

/* Keep only essential non-CPU-intensive styles */
.animate-pulse-green,
.animate-pulse,
.animate-bounce,
.animate-spin,
.animate-fade-in,
.animate-slide-up {
    animation: none !important;
}

/* Disable will-change to prevent GPU layer creation */
* {
    will-change: auto !important;
}

/* Gradient text animation */
@keyframes gradient-x {
    0%, 100% {
        background-size: 200% 200%;
        background-position: left center;
    }
    50% {
        background-size: 200% 200%;
        background-position: right center;
    }
}

.animate-gradient-x {
    animation: gradient-x 3s ease infinite;
}

/* Enhanced card shadows */
.card-shadow {
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06), 
                0 0 0 1px rgba(0, 0, 0, 0.05);
}

.dark .card-shadow {
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2), 
                0 0 0 1px rgba(255, 255, 255, 0.05);
}

/* Loading shimmer effect */
@keyframes shimmer {
    0% {
        background-position: -468px 0;
    }
    100% {
        background-position: 468px 0;
    }
}

.animate-shimmer {
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 37%, #f0f0f0 63%);
    background-size: 400% 100%;
    animation: shimmer 1.4s ease-in-out infinite;
}

.dark .animate-shimmer {
    background: linear-gradient(90deg, #374151 25%, #4b5563 37%, #374151 63%);
    background-size: 400% 100%;
}

/* Responsive utilities */
@media (max-width: 768px) {
    .text-responsive-lg {
        font-size: 1.25rem !important;
        line-height: 1.75rem !important;
    }
    
    .text-responsive-xl {
        font-size: 1.5rem !important;
        line-height: 2rem !important;
    }
}
</style>
`;

// Insert styles into head
document.head.insertAdjacentHTML('beforeend', customStyles);

// Session Analytics Functions - REDUCED frequency to save CPU
let sessionUpdateInterval = null;

function updateSessionStats() {
    // Only update if page is visible
    if (document.hidden) return;

    fetch('/admin/api/dashboard-sessions')
        .then(response => response.json())
        .then(data => {
            // Update dashboard session metrics
            const activeSessionsEl = document.getElementById('dashboard-active-sessions');
            const websocketEl = document.getElementById('dashboard-websocket-count');
            const paymentRateEl = document.getElementById('dashboard-payment-rate');
            const paidAmountEl = document.getElementById('dashboard-paid-amount');

            if (activeSessionsEl) activeSessionsEl.textContent = data.active_sessions || 0;
            if (websocketEl) websocketEl.textContent = data.websocket_count || 0;
            if (paymentRateEl) paymentRateEl.textContent = data.payment_rate ? data.payment_rate.toFixed(1) + '%' : '0%';
            if (paidAmountEl) paidAmountEl.textContent = '$' + (data.paid_amount ? data.paid_amount.toFixed(2) : '0.00');
        })
        .catch(error => {
            console.error('Error updating session stats:', error);
        });
}

function startSessionUpdates() {
    // DISABLED: Session polling disabled to eliminate CPU usage
    // Session stats will only update on manual refresh
    console.log('⚠️ Session auto-updates DISABLED - use manual refresh button to update stats');

    // Initial update only
    updateSessionStats();

    // sessionUpdateInterval = setInterval(() => {
    //     if (!document.hidden) {
    //         updateSessionStats();
    //     }
    // }, 30000);
}

// REMOVED duplicate updateSiteBreakdownTable function - using optimized version above

function startSiteAnalyticsUpdates() {
    // DISABLED: Analytics polling disabled to eliminate CPU usage
    // Analytics will only update on manual refresh
    console.log('⚠️ Analytics auto-updates DISABLED - use manual refresh button to update analytics');

    // Load initial data only
    loadInitialAnalytics();

    // Polling disabled
    // if (useWebSocketAnalytics && typeof WebSocket !== 'undefined') {
    //     initAnalyticsWebSocket();
    // } else {
    //     initAnalyticsPolling();
    // }
}

// CRITICAL: Clean up ALL intervals before HTMX swap to prevent leaks
document.body.addEventListener('htmx:beforeSwap', function(event) {
    if (event.target.id === 'dashboard-content') {
        console.log('🧹 Cleaning up intervals before HTMX swap...');

        // Clear all dashboard intervals
        if (chartUpdateInterval !== null) {
            clearInterval(chartUpdateInterval);
            chartUpdateInterval = null;
        }
        if (sessionUpdateInterval !== null) {
            clearInterval(sessionUpdateInterval);
            sessionUpdateInterval = null;
        }
        if (analyticsPollingTimer !== null) {
            clearTimeout(analyticsPollingTimer);
            analyticsPollingTimer = null;
        }

        // Charts already removed - no cleanup needed

        // Reset initialization flag
        analyticsInitialized = false;

        console.log('✅ Cleanup complete');
    }
});

// Start session and site analytics updates when dashboard loads
document.body.addEventListener('htmx:afterSettle', function(event) {
    if (event.target.id === 'dashboard-content') {
        // Prevent duplicate initialization
        if (analyticsInitialized) {
            console.log('Analytics already initialized, skipping...');
            return;
        }

        analyticsInitialized = true;
        console.log('🚀 Initializing dashboard updates...');

        // Start session updates along with chart updates
        setTimeout(startSessionUpdates, 500);

        // Start site analytics updates (WebSocket with polling fallback)
        setTimeout(startSiteAnalyticsUpdates, 600);
    }
});

// Clean up intervals and WebSocket when navigating away or page hidden
window.addEventListener('beforeunload', () => {
    if (sessionUpdateInterval) {
        clearInterval(sessionUpdateInterval);
    }
    if (chartUpdateInterval) {
        clearInterval(chartUpdateInterval);
    }
    if (analyticsWS) {
        analyticsWS.close();
    }
    if (analyticsPollingTimer) {
        clearTimeout(analyticsPollingTimer);
    }
    console.log('Dashboard cleanup: All intervals and WebSocket connections closed');
    // Charts already removed
});

// Pause updates when page is hidden to save CPU
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        console.log('Page hidden - pausing dashboard updates to save CPU');
    } else {
        console.log('Page visible - resuming dashboard updates');
        // Trigger immediate update when page becomes visible
        if (typeof updateSessionStats === 'function') updateSessionStats();
        if (typeof updateCharts === 'function') {
            fetch('/admin/status')
                .then(response => response.json())
                .then(data => updateCharts(data))
                .catch(error => console.error('Error updating charts:', error));
        }
    }
});
</script>
{{end}}