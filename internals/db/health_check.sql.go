// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: health_check.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountReservedWithPayments = `-- name: CountReservedWithPayments :one
SELECT COUNT(DISTINCT a.address) as count
FROM address_pool_addresses a
INNER JOIN payments p ON p.address = a.address
WHERE a.status = 'reserved'
AND p.status = 'completed'
`

// Count how many reserved addresses have completed payments
func (q *Queries) CountReservedWithPayments(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountReservedWithPayments)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const FindReservedAddressesWithPayments = `-- name: FindReservedAddressesWithPayments :many
SELECT DISTINCT
    a.address,
    a.site,
    a.email,
    COUNT(p.id) as payment_count
FROM address_pool_addresses a
INNER JOIN payments p ON p.address = a.address
WHERE a.status = 'reserved'
AND p.status = 'completed'
GROUP BY a.address, a.site, a.email
`

type FindReservedAddressesWithPaymentsRow struct {
	Address      string  `json:"address"`
	Site         string  `json:"site"`
	Email        *string `json:"email"`
	PaymentCount int64   `json:"payment_count"`
}

// Find addresses marked as "reserved" but have completed payments
func (q *Queries) FindReservedAddressesWithPayments(ctx context.Context) ([]FindReservedAddressesWithPaymentsRow, error) {
	rows, err := q.db.Query(ctx, FindReservedAddressesWithPayments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindReservedAddressesWithPaymentsRow{}
	for rows.Next() {
		var i FindReservedAddressesWithPaymentsRow
		if err := rows.Scan(
			&i.Address,
			&i.Site,
			&i.Email,
			&i.PaymentCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FixNullPaymentCounts = `-- name: FixNullPaymentCounts :exec
UPDATE address_pool_addresses a
SET payment_count = COALESCE((
    SELECT COUNT(*)
    FROM payments p
    WHERE p.address = a.address
    AND p.status = 'completed'
), 0)
WHERE a.status = 'used'
AND a.payment_count IS NULL
`

// Fix addresses marked as "used" but have NULL payment_count
func (q *Queries) FixNullPaymentCounts(ctx context.Context) error {
	_, err := q.db.Exec(ctx, FixNullPaymentCounts)
	return err
}

const FixReservedAddressWithPayment = `-- name: FixReservedAddressWithPayment :exec
UPDATE address_pool_addresses
SET status = 'used',
    used_at = NOW(),
    payment_count = COALESCE(payment_count, 0) + 1,
    last_checked = NOW()
WHERE address = $1
AND status = 'reserved'
`

// Mark a reserved address as used (called by health checker)
func (q *Queries) FixReservedAddressWithPayment(ctx context.Context, address string) error {
	_, err := q.db.Exec(ctx, FixReservedAddressWithPayment, address)
	return err
}

const GetAllAddressesForBlockchainCheck = `-- name: GetAllAddressesForBlockchainCheck :many
SELECT
    address,
    site,
    status,
    email,
    payment_count,
    reserved_at,
    used_at,
    last_checked
FROM address_pool_addresses
ORDER BY
    CASE status
        WHEN 'reserved' THEN 1  -- Check reserved first (most important)
        WHEN 'used' THEN 2      -- Then used (verify they're actually used)
        WHEN 'available' THEN 3 -- Then available (should have no history)
        ELSE 4
    END,
    last_checked ASC
`

type GetAllAddressesForBlockchainCheckRow struct {
	Address      string             `json:"address"`
	Site         string             `json:"site"`
	Status       string             `json:"status"`
	Email        *string            `json:"email"`
	PaymentCount *int32             `json:"payment_count"`
	ReservedAt   pgtype.Timestamptz `json:"reserved_at"`
	UsedAt       pgtype.Timestamptz `json:"used_at"`
	LastChecked  time.Time          `json:"last_checked"`
}

// Get ALL addresses to verify transaction history on blockchain
func (q *Queries) GetAllAddressesForBlockchainCheck(ctx context.Context) ([]GetAllAddressesForBlockchainCheckRow, error) {
	rows, err := q.db.Query(ctx, GetAllAddressesForBlockchainCheck)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllAddressesForBlockchainCheckRow{}
	for rows.Next() {
		var i GetAllAddressesForBlockchainCheckRow
		if err := rows.Scan(
			&i.Address,
			&i.Site,
			&i.Status,
			&i.Email,
			&i.PaymentCount,
			&i.ReservedAt,
			&i.UsedAt,
			&i.LastChecked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAllReservedAddresses = `-- name: GetAllReservedAddresses :many
SELECT
    address,
    site,
    email,
    reserved_at
FROM address_pool_addresses
WHERE status = 'reserved'
ORDER BY reserved_at DESC
`

type GetAllReservedAddressesRow struct {
	Address    string             `json:"address"`
	Site       string             `json:"site"`
	Email      *string            `json:"email"`
	ReservedAt pgtype.Timestamptz `json:"reserved_at"`
}

// Get all reserved addresses for blockchain verification
func (q *Queries) GetAllReservedAddresses(ctx context.Context) ([]GetAllReservedAddressesRow, error) {
	rows, err := q.db.Query(ctx, GetAllReservedAddresses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllReservedAddressesRow{}
	for rows.Next() {
		var i GetAllReservedAddressesRow
		if err := rows.Scan(
			&i.Address,
			&i.Site,
			&i.Email,
			&i.ReservedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetExpiredReservationsForHealthCheck = `-- name: GetExpiredReservationsForHealthCheck :many
SELECT
    address,
    site,
    email,
    reserved_at,
    EXTRACT(EPOCH FROM (NOW() - reserved_at))/3600 as hours_old
FROM address_pool_addresses
WHERE status = 'reserved'
AND reserved_at < NOW() - INTERVAL '72 hours'
ORDER BY reserved_at
`

type GetExpiredReservationsForHealthCheckRow struct {
	Address    string             `json:"address"`
	Site       string             `json:"site"`
	Email      *string            `json:"email"`
	ReservedAt pgtype.Timestamptz `json:"reserved_at"`
	HoursOld   int32              `json:"hours_old"`
}

// Get addresses reserved for >72 hours for health check verification
func (q *Queries) GetExpiredReservationsForHealthCheck(ctx context.Context) ([]GetExpiredReservationsForHealthCheckRow, error) {
	rows, err := q.db.Query(ctx, GetExpiredReservationsForHealthCheck)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExpiredReservationsForHealthCheckRow{}
	for rows.Next() {
		var i GetExpiredReservationsForHealthCheckRow
		if err := rows.Scan(
			&i.Address,
			&i.Site,
			&i.Email,
			&i.ReservedAt,
			&i.HoursOld,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const HealthCheckSummary = `-- name: HealthCheckSummary :one
SELECT
    COUNT(*) as total_addresses,
    COUNT(*) FILTER (WHERE status = 'available') as available_count,
    COUNT(*) FILTER (WHERE status = 'reserved') as reserved_count,
    COUNT(*) FILTER (WHERE status = 'used') as used_count,
    COUNT(*) FILTER (WHERE status = 'reserved' AND reserved_at < NOW() - INTERVAL '72 hours') as expired_reservations,
    COUNT(*) FILTER (WHERE status = 'used' AND payment_count IS NULL) as null_payment_counts,
    COUNT(*) FILTER (WHERE status = 'used' AND used_at IS NULL) as null_used_timestamps,
    (SELECT COUNT(*) FROM address_pool_queue q
     JOIN address_pool_addresses a ON a.address = q.address
     WHERE a.status = 'used') as used_in_queue
FROM address_pool_addresses
`

type HealthCheckSummaryRow struct {
	TotalAddresses      int64 `json:"total_addresses"`
	AvailableCount      int64 `json:"available_count"`
	ReservedCount       int64 `json:"reserved_count"`
	UsedCount           int64 `json:"used_count"`
	ExpiredReservations int64 `json:"expired_reservations"`
	NullPaymentCounts   int64 `json:"null_payment_counts"`
	NullUsedTimestamps  int64 `json:"null_used_timestamps"`
	UsedInQueue         int64 `json:"used_in_queue"`
}

// Get overall health check summary
func (q *Queries) HealthCheckSummary(ctx context.Context) (HealthCheckSummaryRow, error) {
	row := q.db.QueryRow(ctx, HealthCheckSummary)
	var i HealthCheckSummaryRow
	err := row.Scan(
		&i.TotalAddresses,
		&i.AvailableCount,
		&i.ReservedCount,
		&i.UsedCount,
		&i.ExpiredReservations,
		&i.NullPaymentCounts,
		&i.NullUsedTimestamps,
		&i.UsedInQueue,
	)
	return i, err
}

const RemoveUsedAddressesFromQueue = `-- name: RemoveUsedAddressesFromQueue :exec
DELETE FROM address_pool_queue q
WHERE EXISTS (
    SELECT 1 FROM address_pool_addresses a
    WHERE a.address = q.address
    AND a.status = 'used'
)
`

// Remove all "used" addresses from the queue
func (q *Queries) RemoveUsedAddressesFromQueue(ctx context.Context) error {
	_, err := q.db.Exec(ctx, RemoveUsedAddressesFromQueue)
	return err
}
