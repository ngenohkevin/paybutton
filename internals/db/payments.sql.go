// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: payments.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountPaymentsWithFilters = `-- name: CountPaymentsWithFilters :one
SELECT COUNT(*) FROM payments
WHERE
    ($1::text IS NULL OR site = $1)
    AND ($2::text IS NULL OR status = $2)
    AND (
        $3::text IS NULL
        OR email ILIKE '%' || $3 || '%'
        OR payment_id ILIKE '%' || $3 || '%'
        OR address ILIKE '%' || $3 || '%'
    )
    AND (
        $4::timestamptz IS NULL
        OR created_at >= $4
    )
    AND (
        $5::timestamptz IS NULL
        OR created_at <= $5
    )
`

type CountPaymentsWithFiltersParams struct {
	Site      *string            `json:"site"`
	Status    *string            `json:"status"`
	Search    *string            `json:"search"`
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

func (q *Queries) CountPaymentsWithFilters(ctx context.Context, arg CountPaymentsWithFiltersParams) (int64, error) {
	row := q.db.QueryRow(ctx, CountPaymentsWithFilters,
		arg.Site,
		arg.Status,
		arg.Search,
		arg.StartDate,
		arg.EndDate,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreatePayment = `-- name: CreatePayment :one
INSERT INTO payments (
    payment_id,
    address,
    site,
    amount_btc,
    amount_usd,
    currency,
    email,
    order_id,
    user_agent,
    ip_address,
    required_confirmations,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, payment_id, address, site, tx_hash, amount_btc, amount_usd, currency, confirmations, required_confirmations, status, email, order_id, user_agent, ip_address, payment_initiated_at, first_seen_at, confirmed_at, completed_at, expires_at, notes, webhook_sent, webhook_sent_at, email_sent, email_sent_at, telegram_sent, telegram_sent_at, created_at, updated_at
`

type CreatePaymentParams struct {
	PaymentID             string             `json:"payment_id"`
	Address               string             `json:"address"`
	Site                  string             `json:"site"`
	AmountBtc             pgtype.Numeric     `json:"amount_btc"`
	AmountUsd             pgtype.Numeric     `json:"amount_usd"`
	Currency              string             `json:"currency"`
	Email                 *string            `json:"email"`
	OrderID               *string            `json:"order_id"`
	UserAgent             *string            `json:"user_agent"`
	IpAddress             *string            `json:"ip_address"`
	RequiredConfirmations *int32             `json:"required_confirmations"`
	ExpiresAt             pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, CreatePayment,
		arg.PaymentID,
		arg.Address,
		arg.Site,
		arg.AmountBtc,
		arg.AmountUsd,
		arg.Currency,
		arg.Email,
		arg.OrderID,
		arg.UserAgent,
		arg.IpAddress,
		arg.RequiredConfirmations,
		arg.ExpiresAt,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.Address,
		&i.Site,
		&i.TxHash,
		&i.AmountBtc,
		&i.AmountUsd,
		&i.Currency,
		&i.Confirmations,
		&i.RequiredConfirmations,
		&i.Status,
		&i.Email,
		&i.OrderID,
		&i.UserAgent,
		&i.IpAddress,
		&i.PaymentInitiatedAt,
		&i.FirstSeenAt,
		&i.ConfirmedAt,
		&i.CompletedAt,
		&i.ExpiresAt,
		&i.Notes,
		&i.WebhookSent,
		&i.WebhookSentAt,
		&i.EmailSent,
		&i.EmailSentAt,
		&i.TelegramSent,
		&i.TelegramSentAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteExpiredPaymentsByAddress = `-- name: DeleteExpiredPaymentsByAddress :exec
DELETE FROM payments
WHERE address = $1
  AND status = 'expired'
`

// Delete expired payments for a specific address (used when address is recycled)
func (q *Queries) DeleteExpiredPaymentsByAddress(ctx context.Context, address string) error {
	_, err := q.db.Exec(ctx, DeleteExpiredPaymentsByAddress, address)
	return err
}

const DeleteOldPayments = `-- name: DeleteOldPayments :exec
DELETE FROM payments
WHERE created_at < $1
`

func (q *Queries) DeleteOldPayments(ctx context.Context, createdAt time.Time) error {
	_, err := q.db.Exec(ctx, DeleteOldPayments, createdAt)
	return err
}

const DeletePayment = `-- name: DeletePayment :exec
DELETE FROM payments
WHERE payment_id = $1
`

func (q *Queries) DeletePayment(ctx context.Context, paymentID string) error {
	_, err := q.db.Exec(ctx, DeletePayment, paymentID)
	return err
}

const GetActivePendingPayments = `-- name: GetActivePendingPayments :many
SELECT
    payment_id,
    address,
    site,
    amount_btc,
    amount_usd,
    email,
    status,
    confirmations,
    required_confirmations,
    created_at,
    expires_at,
    EXTRACT(EPOCH FROM (expires_at - NOW())) as seconds_until_expiry
FROM payments
WHERE status IN ('pending', 'detected', 'confirming')
  AND expires_at > NOW()
ORDER BY created_at DESC
`

type GetActivePendingPaymentsRow struct {
	PaymentID             string             `json:"payment_id"`
	Address               string             `json:"address"`
	Site                  string             `json:"site"`
	AmountBtc             pgtype.Numeric     `json:"amount_btc"`
	AmountUsd             pgtype.Numeric     `json:"amount_usd"`
	Email                 *string            `json:"email"`
	Status                string             `json:"status"`
	Confirmations         *int32             `json:"confirmations"`
	RequiredConfirmations *int32             `json:"required_confirmations"`
	CreatedAt             time.Time          `json:"created_at"`
	ExpiresAt             pgtype.Timestamptz `json:"expires_at"`
	SecondsUntilExpiry    pgtype.Numeric     `json:"seconds_until_expiry"`
}

// Get currently active pending payments for monitoring
func (q *Queries) GetActivePendingPayments(ctx context.Context) ([]GetActivePendingPaymentsRow, error) {
	rows, err := q.db.Query(ctx, GetActivePendingPayments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActivePendingPaymentsRow{}
	for rows.Next() {
		var i GetActivePendingPaymentsRow
		if err := rows.Scan(
			&i.PaymentID,
			&i.Address,
			&i.Site,
			&i.AmountBtc,
			&i.AmountUsd,
			&i.Email,
			&i.Status,
			&i.Confirmations,
			&i.RequiredConfirmations,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.SecondsUntilExpiry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAverageConfirmationTime = `-- name: GetAverageConfirmationTime :one
SELECT
    COUNT(*) FILTER (WHERE confirmed_at IS NOT NULL) as confirmed_count,
    AVG(EXTRACT(EPOCH FROM (confirmed_at - first_seen_at))) as avg_confirmation_seconds,
    AVG(EXTRACT(EPOCH FROM (completed_at - created_at))) as avg_completion_seconds,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY EXTRACT(EPOCH FROM (confirmed_at - first_seen_at))) as median_confirmation_seconds
FROM payments
WHERE confirmed_at IS NOT NULL
  AND first_seen_at IS NOT NULL
  AND created_at >= $1
`

type GetAverageConfirmationTimeRow struct {
	ConfirmedCount            int64   `json:"confirmed_count"`
	AvgConfirmationSeconds    float64 `json:"avg_confirmation_seconds"`
	AvgCompletionSeconds      float64 `json:"avg_completion_seconds"`
	MedianConfirmationSeconds float64 `json:"median_confirmation_seconds"`
}

// Get average time from payment creation to confirmation
func (q *Queries) GetAverageConfirmationTime(ctx context.Context, createdAt time.Time) (GetAverageConfirmationTimeRow, error) {
	row := q.db.QueryRow(ctx, GetAverageConfirmationTime, createdAt)
	var i GetAverageConfirmationTimeRow
	err := row.Scan(
		&i.ConfirmedCount,
		&i.AvgConfirmationSeconds,
		&i.AvgCompletionSeconds,
		&i.MedianConfirmationSeconds,
	)
	return i, err
}

const GetDailyPaymentStats = `-- name: GetDailyPaymentStats :many
SELECT
    DATE(created_at) as date,
    COUNT(*) as payment_count,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_count,
    COALESCE(SUM(amount_btc) FILTER (WHERE status = 'completed'), 0) as total_btc,
    COALESCE(SUM(amount_usd) FILTER (WHERE status = 'completed'), 0) as total_usd
FROM payments
WHERE site = $1
  AND created_at >= $2
GROUP BY DATE(created_at)
ORDER BY date DESC
`

type GetDailyPaymentStatsParams struct {
	Site      string    `json:"site"`
	CreatedAt time.Time `json:"created_at"`
}

type GetDailyPaymentStatsRow struct {
	Date           pgtype.Date `json:"date"`
	PaymentCount   int64       `json:"payment_count"`
	CompletedCount int64       `json:"completed_count"`
	TotalBtc       interface{} `json:"total_btc"`
	TotalUsd       interface{} `json:"total_usd"`
}

func (q *Queries) GetDailyPaymentStats(ctx context.Context, arg GetDailyPaymentStatsParams) ([]GetDailyPaymentStatsRow, error) {
	rows, err := q.db.Query(ctx, GetDailyPaymentStats, arg.Site, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDailyPaymentStatsRow{}
	for rows.Next() {
		var i GetDailyPaymentStatsRow
		if err := rows.Scan(
			&i.Date,
			&i.PaymentCount,
			&i.CompletedCount,
			&i.TotalBtc,
			&i.TotalUsd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDashboardOverview = `-- name: GetDashboardOverview :one

SELECT
    COUNT(*) as total_payments,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_payments,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_payments,
    COUNT(*) FILTER (WHERE status = 'confirming') as confirming_payments,
    COUNT(*) FILTER (WHERE status = 'expired') as expired_payments,
    COUNT(*) FILTER (WHERE status = 'failed') as failed_payments,
    COALESCE(SUM(amount_btc) FILTER (WHERE status = 'completed'), 0) as total_btc_received,
    COALESCE(SUM(amount_usd) FILTER (WHERE status = 'completed'), 0) as total_usd_received,
    COALESCE(AVG(amount_btc) FILTER (WHERE status = 'completed'), 0) as avg_btc_per_payment,
    COALESCE(AVG(amount_usd) FILTER (WHERE status = 'completed'), 0) as avg_usd_per_payment,
    COUNT(DISTINCT site) as total_sites,
    COUNT(DISTINCT address) as total_addresses_used,
    COUNT(*) FILTER (WHERE created_at >= NOW() - INTERVAL '24 hours') as payments_last_24h,
    COUNT(*) FILTER (WHERE created_at >= NOW() - INTERVAL '1 hour') as payments_last_hour,
    COUNT(*) FILTER (WHERE status = 'completed' AND confirmed_at >= NOW() - INTERVAL '24 hours') as completed_last_24h
FROM payments
`

type GetDashboardOverviewRow struct {
	TotalPayments      int64       `json:"total_payments"`
	CompletedPayments  int64       `json:"completed_payments"`
	PendingPayments    int64       `json:"pending_payments"`
	ConfirmingPayments int64       `json:"confirming_payments"`
	ExpiredPayments    int64       `json:"expired_payments"`
	FailedPayments     int64       `json:"failed_payments"`
	TotalBtcReceived   interface{} `json:"total_btc_received"`
	TotalUsdReceived   interface{} `json:"total_usd_received"`
	AvgBtcPerPayment   interface{} `json:"avg_btc_per_payment"`
	AvgUsdPerPayment   interface{} `json:"avg_usd_per_payment"`
	TotalSites         int64       `json:"total_sites"`
	TotalAddressesUsed int64       `json:"total_addresses_used"`
	PaymentsLast24h    int64       `json:"payments_last_24h"`
	PaymentsLastHour   int64       `json:"payments_last_hour"`
	CompletedLast24h   int64       `json:"completed_last_24h"`
}

// Dashboard Queries
// Get comprehensive dashboard statistics across all sites
func (q *Queries) GetDashboardOverview(ctx context.Context) (GetDashboardOverviewRow, error) {
	row := q.db.QueryRow(ctx, GetDashboardOverview)
	var i GetDashboardOverviewRow
	err := row.Scan(
		&i.TotalPayments,
		&i.CompletedPayments,
		&i.PendingPayments,
		&i.ConfirmingPayments,
		&i.ExpiredPayments,
		&i.FailedPayments,
		&i.TotalBtcReceived,
		&i.TotalUsdReceived,
		&i.AvgBtcPerPayment,
		&i.AvgUsdPerPayment,
		&i.TotalSites,
		&i.TotalAddressesUsed,
		&i.PaymentsLast24h,
		&i.PaymentsLastHour,
		&i.CompletedLast24h,
	)
	return i, err
}

const GetHourlyPaymentTrend = `-- name: GetHourlyPaymentTrend :many
SELECT
    DATE_TRUNC('hour', created_at) as hour,
    COUNT(*) as payment_count,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_count,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_count,
    COALESCE(SUM(amount_btc) FILTER (WHERE status = 'completed'), 0) as btc_volume,
    COALESCE(SUM(amount_usd) FILTER (WHERE status = 'completed'), 0) as usd_volume
FROM payments
WHERE created_at >= NOW() - INTERVAL '24 hours'
GROUP BY DATE_TRUNC('hour', created_at)
ORDER BY hour DESC
`

type GetHourlyPaymentTrendRow struct {
	Hour           pgtype.Interval `json:"hour"`
	PaymentCount   int64           `json:"payment_count"`
	CompletedCount int64           `json:"completed_count"`
	PendingCount   int64           `json:"pending_count"`
	BtcVolume      interface{}     `json:"btc_volume"`
	UsdVolume      interface{}     `json:"usd_volume"`
}

// Get hourly payment trends for the last 24 hours
func (q *Queries) GetHourlyPaymentTrend(ctx context.Context) ([]GetHourlyPaymentTrendRow, error) {
	rows, err := q.db.Query(ctx, GetHourlyPaymentTrend)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHourlyPaymentTrendRow{}
	for rows.Next() {
		var i GetHourlyPaymentTrendRow
		if err := rows.Scan(
			&i.Hour,
			&i.PaymentCount,
			&i.CompletedCount,
			&i.PendingCount,
			&i.BtcVolume,
			&i.UsdVolume,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPayment = `-- name: GetPayment :one
SELECT id, payment_id, address, site, tx_hash, amount_btc, amount_usd, currency, confirmations, required_confirmations, status, email, order_id, user_agent, ip_address, payment_initiated_at, first_seen_at, confirmed_at, completed_at, expires_at, notes, webhook_sent, webhook_sent_at, email_sent, email_sent_at, telegram_sent, telegram_sent_at, created_at, updated_at FROM payments
WHERE payment_id = $1
`

func (q *Queries) GetPayment(ctx context.Context, paymentID string) (Payment, error) {
	row := q.db.QueryRow(ctx, GetPayment, paymentID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.Address,
		&i.Site,
		&i.TxHash,
		&i.AmountBtc,
		&i.AmountUsd,
		&i.Currency,
		&i.Confirmations,
		&i.RequiredConfirmations,
		&i.Status,
		&i.Email,
		&i.OrderID,
		&i.UserAgent,
		&i.IpAddress,
		&i.PaymentInitiatedAt,
		&i.FirstSeenAt,
		&i.ConfirmedAt,
		&i.CompletedAt,
		&i.ExpiresAt,
		&i.Notes,
		&i.WebhookSent,
		&i.WebhookSentAt,
		&i.EmailSent,
		&i.EmailSentAt,
		&i.TelegramSent,
		&i.TelegramSentAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetPaymentByAddress = `-- name: GetPaymentByAddress :one
SELECT id, payment_id, address, site, tx_hash, amount_btc, amount_usd, currency, confirmations, required_confirmations, status, email, order_id, user_agent, ip_address, payment_initiated_at, first_seen_at, confirmed_at, completed_at, expires_at, notes, webhook_sent, webhook_sent_at, email_sent, email_sent_at, telegram_sent, telegram_sent_at, created_at, updated_at FROM payments
WHERE address = $1 AND status != 'expired'
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetPaymentByAddress(ctx context.Context, address string) (Payment, error) {
	row := q.db.QueryRow(ctx, GetPaymentByAddress, address)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.Address,
		&i.Site,
		&i.TxHash,
		&i.AmountBtc,
		&i.AmountUsd,
		&i.Currency,
		&i.Confirmations,
		&i.RequiredConfirmations,
		&i.Status,
		&i.Email,
		&i.OrderID,
		&i.UserAgent,
		&i.IpAddress,
		&i.PaymentInitiatedAt,
		&i.FirstSeenAt,
		&i.ConfirmedAt,
		&i.CompletedAt,
		&i.ExpiresAt,
		&i.Notes,
		&i.WebhookSent,
		&i.WebhookSentAt,
		&i.EmailSent,
		&i.EmailSentAt,
		&i.TelegramSent,
		&i.TelegramSentAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetPaymentConversionRate = `-- name: GetPaymentConversionRate :one
SELECT
    COUNT(*) as total_initiated,
    COUNT(*) FILTER (WHERE status = 'completed') as total_completed,
    CASE
        WHEN COUNT(*) > 0 THEN
            (COUNT(*) FILTER (WHERE status = 'completed')::float / COUNT(*)::float) * 100
        ELSE 0
    END as conversion_rate,
    CASE
        WHEN COUNT(*) > 0 THEN
            (COUNT(*) FILTER (WHERE status = 'expired')::float / COUNT(*)::float) * 100
        ELSE 0
    END as expiration_rate
FROM payments
WHERE created_at >= $1
`

type GetPaymentConversionRateRow struct {
	TotalInitiated int64 `json:"total_initiated"`
	TotalCompleted int64 `json:"total_completed"`
	ConversionRate int32 `json:"conversion_rate"`
	ExpirationRate int32 `json:"expiration_rate"`
}

// Calculate payment success/conversion rate
func (q *Queries) GetPaymentConversionRate(ctx context.Context, createdAt time.Time) (GetPaymentConversionRateRow, error) {
	row := q.db.QueryRow(ctx, GetPaymentConversionRate, createdAt)
	var i GetPaymentConversionRateRow
	err := row.Scan(
		&i.TotalInitiated,
		&i.TotalCompleted,
		&i.ConversionRate,
		&i.ExpirationRate,
	)
	return i, err
}

const GetPaymentCountByStatus = `-- name: GetPaymentCountByStatus :many
SELECT
    status,
    COUNT(*) as count
FROM payments
WHERE site = $1
GROUP BY status
`

type GetPaymentCountByStatusRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

func (q *Queries) GetPaymentCountByStatus(ctx context.Context, site string) ([]GetPaymentCountByStatusRow, error) {
	rows, err := q.db.Query(ctx, GetPaymentCountByStatus, site)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaymentCountByStatusRow{}
	for rows.Next() {
		var i GetPaymentCountByStatusRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPaymentStats = `-- name: GetPaymentStats :one
SELECT
    COUNT(*) as total_payments,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_count,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_count,
    COUNT(*) FILTER (WHERE status = 'expired') as expired_count,
    COALESCE(SUM(amount_btc) FILTER (WHERE status = 'completed'), 0) as total_btc,
    COALESCE(SUM(amount_usd) FILTER (WHERE status = 'completed'), 0) as total_usd,
    COALESCE(AVG(amount_btc) FILTER (WHERE status = 'completed'), 0) as avg_btc,
    COALESCE(AVG(amount_usd) FILTER (WHERE status = 'completed'), 0) as avg_usd
FROM payments
WHERE site = $1
`

type GetPaymentStatsRow struct {
	TotalPayments  int64       `json:"total_payments"`
	CompletedCount int64       `json:"completed_count"`
	PendingCount   int64       `json:"pending_count"`
	ExpiredCount   int64       `json:"expired_count"`
	TotalBtc       interface{} `json:"total_btc"`
	TotalUsd       interface{} `json:"total_usd"`
	AvgBtc         interface{} `json:"avg_btc"`
	AvgUsd         interface{} `json:"avg_usd"`
}

func (q *Queries) GetPaymentStats(ctx context.Context, site string) (GetPaymentStatsRow, error) {
	row := q.db.QueryRow(ctx, GetPaymentStats, site)
	var i GetPaymentStatsRow
	err := row.Scan(
		&i.TotalPayments,
		&i.CompletedCount,
		&i.PendingCount,
		&i.ExpiredCount,
		&i.TotalBtc,
		&i.TotalUsd,
		&i.AvgBtc,
		&i.AvgUsd,
	)
	return i, err
}

const GetPaymentStatsByDateRange = `-- name: GetPaymentStatsByDateRange :one
SELECT
    COUNT(*) as total_payments,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_count,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_count,
    COUNT(*) FILTER (WHERE status = 'expired') as expired_count,
    COALESCE(SUM(amount_btc) FILTER (WHERE status = 'completed'), 0) as total_btc,
    COALESCE(SUM(amount_usd) FILTER (WHERE status = 'completed'), 0) as total_usd,
    COALESCE(AVG(amount_btc) FILTER (WHERE status = 'completed'), 0) as avg_btc,
    COALESCE(AVG(amount_usd) FILTER (WHERE status = 'completed'), 0) as avg_usd
FROM payments
WHERE site = $1
  AND created_at BETWEEN $2 AND $3
`

type GetPaymentStatsByDateRangeParams struct {
	Site        string    `json:"site"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetPaymentStatsByDateRangeRow struct {
	TotalPayments  int64       `json:"total_payments"`
	CompletedCount int64       `json:"completed_count"`
	PendingCount   int64       `json:"pending_count"`
	ExpiredCount   int64       `json:"expired_count"`
	TotalBtc       interface{} `json:"total_btc"`
	TotalUsd       interface{} `json:"total_usd"`
	AvgBtc         interface{} `json:"avg_btc"`
	AvgUsd         interface{} `json:"avg_usd"`
}

func (q *Queries) GetPaymentStatsByDateRange(ctx context.Context, arg GetPaymentStatsByDateRangeParams) (GetPaymentStatsByDateRangeRow, error) {
	row := q.db.QueryRow(ctx, GetPaymentStatsByDateRange, arg.Site, arg.CreatedAt, arg.CreatedAt_2)
	var i GetPaymentStatsByDateRangeRow
	err := row.Scan(
		&i.TotalPayments,
		&i.CompletedCount,
		&i.PendingCount,
		&i.ExpiredCount,
		&i.TotalBtc,
		&i.TotalUsd,
		&i.AvgBtc,
		&i.AvgUsd,
	)
	return i, err
}

const GetPaymentStatusDistribution = `-- name: GetPaymentStatusDistribution :many
SELECT
    status,
    COUNT(*) as count,
    COALESCE(SUM(amount_usd), 0) as total_usd
FROM payments
GROUP BY status
ORDER BY count DESC
`

type GetPaymentStatusDistributionRow struct {
	Status   string      `json:"status"`
	Count    int64       `json:"count"`
	TotalUsd interface{} `json:"total_usd"`
}

// Get count of payments by status for dashboard pie chart
func (q *Queries) GetPaymentStatusDistribution(ctx context.Context) ([]GetPaymentStatusDistributionRow, error) {
	rows, err := q.db.Query(ctx, GetPaymentStatusDistribution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaymentStatusDistributionRow{}
	for rows.Next() {
		var i GetPaymentStatusDistributionRow
		if err := rows.Scan(&i.Status, &i.Count, &i.TotalUsd); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPaymentsByDateRange = `-- name: GetPaymentsByDateRange :many
SELECT id, payment_id, address, site, tx_hash, amount_btc, amount_usd, currency, confirmations, required_confirmations, status, email, order_id, user_agent, ip_address, payment_initiated_at, first_seen_at, confirmed_at, completed_at, expires_at, notes, webhook_sent, webhook_sent_at, email_sent, email_sent_at, telegram_sent, telegram_sent_at, created_at, updated_at FROM payments
WHERE site = $1
  AND created_at BETWEEN $2 AND $3
ORDER BY created_at DESC
`

type GetPaymentsByDateRangeParams struct {
	Site        string    `json:"site"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

func (q *Queries) GetPaymentsByDateRange(ctx context.Context, arg GetPaymentsByDateRangeParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, GetPaymentsByDateRange, arg.Site, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.Address,
			&i.Site,
			&i.TxHash,
			&i.AmountBtc,
			&i.AmountUsd,
			&i.Currency,
			&i.Confirmations,
			&i.RequiredConfirmations,
			&i.Status,
			&i.Email,
			&i.OrderID,
			&i.UserAgent,
			&i.IpAddress,
			&i.PaymentInitiatedAt,
			&i.FirstSeenAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
			&i.Notes,
			&i.WebhookSent,
			&i.WebhookSentAt,
			&i.EmailSent,
			&i.EmailSentAt,
			&i.TelegramSent,
			&i.TelegramSentAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRecentCompletedPayments = `-- name: GetRecentCompletedPayments :many
SELECT
    payment_id,
    address,
    site,
    amount_btc,
    amount_usd,
    currency,
    status,
    confirmations,
    required_confirmations,
    email,
    tx_hash,
    created_at,
    confirmed_at,
    completed_at
FROM payments
WHERE status IN ('completed', 'confirmed')
ORDER BY COALESCE(completed_at, confirmed_at, created_at) DESC
LIMIT $1 OFFSET $2
`

type GetRecentCompletedPaymentsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetRecentCompletedPaymentsRow struct {
	PaymentID             string             `json:"payment_id"`
	Address               string             `json:"address"`
	Site                  string             `json:"site"`
	AmountBtc             pgtype.Numeric     `json:"amount_btc"`
	AmountUsd             pgtype.Numeric     `json:"amount_usd"`
	Currency              string             `json:"currency"`
	Status                string             `json:"status"`
	Confirmations         *int32             `json:"confirmations"`
	RequiredConfirmations *int32             `json:"required_confirmations"`
	Email                 *string            `json:"email"`
	TxHash                *string            `json:"tx_hash"`
	CreatedAt             time.Time          `json:"created_at"`
	ConfirmedAt           pgtype.Timestamptz `json:"confirmed_at"`
	CompletedAt           pgtype.Timestamptz `json:"completed_at"`
}

// Get recent completed payments only (actually paid)
func (q *Queries) GetRecentCompletedPayments(ctx context.Context, arg GetRecentCompletedPaymentsParams) ([]GetRecentCompletedPaymentsRow, error) {
	rows, err := q.db.Query(ctx, GetRecentCompletedPayments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentCompletedPaymentsRow{}
	for rows.Next() {
		var i GetRecentCompletedPaymentsRow
		if err := rows.Scan(
			&i.PaymentID,
			&i.Address,
			&i.Site,
			&i.AmountBtc,
			&i.AmountUsd,
			&i.Currency,
			&i.Status,
			&i.Confirmations,
			&i.RequiredConfirmations,
			&i.Email,
			&i.TxHash,
			&i.CreatedAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRecentPayments = `-- name: GetRecentPayments :many
SELECT id, payment_id, address, site, tx_hash, amount_btc, amount_usd, currency, confirmations, required_confirmations, status, email, order_id, user_agent, ip_address, payment_initiated_at, first_seen_at, confirmed_at, completed_at, expires_at, notes, webhook_sent, webhook_sent_at, email_sent, email_sent_at, telegram_sent, telegram_sent_at, created_at, updated_at FROM payments
WHERE site = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetRecentPaymentsParams struct {
	Site  string `json:"site"`
	Limit int32  `json:"limit"`
}

func (q *Queries) GetRecentPayments(ctx context.Context, arg GetRecentPaymentsParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, GetRecentPayments, arg.Site, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.Address,
			&i.Site,
			&i.TxHash,
			&i.AmountBtc,
			&i.AmountUsd,
			&i.Currency,
			&i.Confirmations,
			&i.RequiredConfirmations,
			&i.Status,
			&i.Email,
			&i.OrderID,
			&i.UserAgent,
			&i.IpAddress,
			&i.PaymentInitiatedAt,
			&i.FirstSeenAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
			&i.Notes,
			&i.WebhookSent,
			&i.WebhookSentAt,
			&i.EmailSent,
			&i.EmailSentAt,
			&i.TelegramSent,
			&i.TelegramSentAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRecentPaymentsAllSites = `-- name: GetRecentPaymentsAllSites :many
SELECT
    payment_id,
    address,
    site,
    amount_btc,
    amount_usd,
    currency,
    status,
    confirmations,
    required_confirmations,
    email,
    tx_hash,
    created_at,
    confirmed_at,
    completed_at
FROM payments
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetRecentPaymentsAllSitesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetRecentPaymentsAllSitesRow struct {
	PaymentID             string             `json:"payment_id"`
	Address               string             `json:"address"`
	Site                  string             `json:"site"`
	AmountBtc             pgtype.Numeric     `json:"amount_btc"`
	AmountUsd             pgtype.Numeric     `json:"amount_usd"`
	Currency              string             `json:"currency"`
	Status                string             `json:"status"`
	Confirmations         *int32             `json:"confirmations"`
	RequiredConfirmations *int32             `json:"required_confirmations"`
	Email                 *string            `json:"email"`
	TxHash                *string            `json:"tx_hash"`
	CreatedAt             time.Time          `json:"created_at"`
	ConfirmedAt           pgtype.Timestamptz `json:"confirmed_at"`
	CompletedAt           pgtype.Timestamptz `json:"completed_at"`
}

// Get recent payments across all sites with pagination
func (q *Queries) GetRecentPaymentsAllSites(ctx context.Context, arg GetRecentPaymentsAllSitesParams) ([]GetRecentPaymentsAllSitesRow, error) {
	rows, err := q.db.Query(ctx, GetRecentPaymentsAllSites, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentPaymentsAllSitesRow{}
	for rows.Next() {
		var i GetRecentPaymentsAllSitesRow
		if err := rows.Scan(
			&i.PaymentID,
			&i.Address,
			&i.Site,
			&i.AmountBtc,
			&i.AmountUsd,
			&i.Currency,
			&i.Status,
			&i.Confirmations,
			&i.RequiredConfirmations,
			&i.Email,
			&i.TxHash,
			&i.CreatedAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSiteBreakdown = `-- name: GetSiteBreakdown :many
SELECT
    site,
    COUNT(*) as total_payments,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_payments,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_payments,
    COALESCE(SUM(amount_btc) FILTER (WHERE status = 'completed'), 0) as total_btc,
    COALESCE(SUM(amount_usd) FILTER (WHERE status = 'completed'), 0) as total_usd,
    MAX(created_at) as last_payment_at
FROM payments
GROUP BY site
ORDER BY total_payments DESC
`

type GetSiteBreakdownRow struct {
	Site              string      `json:"site"`
	TotalPayments     int64       `json:"total_payments"`
	CompletedPayments int64       `json:"completed_payments"`
	PendingPayments   int64       `json:"pending_payments"`
	TotalBtc          interface{} `json:"total_btc"`
	TotalUsd          interface{} `json:"total_usd"`
	LastPaymentAt     interface{} `json:"last_payment_at"`
}

// Get payment breakdown by site for dashboard
func (q *Queries) GetSiteBreakdown(ctx context.Context) ([]GetSiteBreakdownRow, error) {
	rows, err := q.db.Query(ctx, GetSiteBreakdown)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSiteBreakdownRow{}
	for rows.Next() {
		var i GetSiteBreakdownRow
		if err := rows.Scan(
			&i.Site,
			&i.TotalPayments,
			&i.CompletedPayments,
			&i.PendingPayments,
			&i.TotalBtc,
			&i.TotalUsd,
			&i.LastPaymentAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTodayStatistics = `-- name: GetTodayStatistics :one
SELECT
    COUNT(*) as total_today,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_today,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_today,
    COALESCE(SUM(amount_btc) FILTER (WHERE status = 'completed'), 0) as btc_today,
    COALESCE(SUM(amount_usd) FILTER (WHERE status = 'completed'), 0) as usd_today,
    COUNT(DISTINCT site) as active_sites_today,
    COUNT(DISTINCT email) FILTER (WHERE email IS NOT NULL AND email != '') as unique_customers_today
FROM payments
WHERE DATE(created_at) = CURRENT_DATE
`

type GetTodayStatisticsRow struct {
	TotalToday           int64       `json:"total_today"`
	CompletedToday       int64       `json:"completed_today"`
	PendingToday         int64       `json:"pending_today"`
	BtcToday             interface{} `json:"btc_today"`
	UsdToday             interface{} `json:"usd_today"`
	ActiveSitesToday     int64       `json:"active_sites_today"`
	UniqueCustomersToday int64       `json:"unique_customers_today"`
}

// Get today's statistics for dashboard summary
func (q *Queries) GetTodayStatistics(ctx context.Context) (GetTodayStatisticsRow, error) {
	row := q.db.QueryRow(ctx, GetTodayStatistics)
	var i GetTodayStatisticsRow
	err := row.Scan(
		&i.TotalToday,
		&i.CompletedToday,
		&i.PendingToday,
		&i.BtcToday,
		&i.UsdToday,
		&i.ActiveSitesToday,
		&i.UniqueCustomersToday,
	)
	return i, err
}

const GetTopPaymentEmails = `-- name: GetTopPaymentEmails :many
SELECT
    email,
    COUNT(*) as payment_count,
    COALESCE(SUM(amount_btc) FILTER (WHERE status = 'completed'), 0) as total_btc,
    COALESCE(SUM(amount_usd) FILTER (WHERE status = 'completed'), 0) as total_usd,
    MAX(created_at) as last_payment_at
FROM payments
WHERE email IS NOT NULL AND email != ''
GROUP BY email
ORDER BY payment_count DESC
LIMIT $1
`

type GetTopPaymentEmailsRow struct {
	Email         *string     `json:"email"`
	PaymentCount  int64       `json:"payment_count"`
	TotalBtc      interface{} `json:"total_btc"`
	TotalUsd      interface{} `json:"total_usd"`
	LastPaymentAt interface{} `json:"last_payment_at"`
}

// Get top paying email addresses
func (q *Queries) GetTopPaymentEmails(ctx context.Context, limit int32) ([]GetTopPaymentEmailsRow, error) {
	rows, err := q.db.Query(ctx, GetTopPaymentEmails, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopPaymentEmailsRow{}
	for rows.Next() {
		var i GetTopPaymentEmailsRow
		if err := rows.Scan(
			&i.Email,
			&i.PaymentCount,
			&i.TotalBtc,
			&i.TotalUsd,
			&i.LastPaymentAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListExpiredPayments = `-- name: ListExpiredPayments :many
SELECT id, payment_id, address, site, tx_hash, amount_btc, amount_usd, currency, confirmations, required_confirmations, status, email, order_id, user_agent, ip_address, payment_initiated_at, first_seen_at, confirmed_at, completed_at, expires_at, notes, webhook_sent, webhook_sent_at, email_sent, email_sent_at, telegram_sent, telegram_sent_at, created_at, updated_at FROM payments
WHERE status = 'pending'
  AND expires_at < NOW()
ORDER BY expires_at ASC
`

func (q *Queries) ListExpiredPayments(ctx context.Context) ([]Payment, error) {
	rows, err := q.db.Query(ctx, ListExpiredPayments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.Address,
			&i.Site,
			&i.TxHash,
			&i.AmountBtc,
			&i.AmountUsd,
			&i.Currency,
			&i.Confirmations,
			&i.RequiredConfirmations,
			&i.Status,
			&i.Email,
			&i.OrderID,
			&i.UserAgent,
			&i.IpAddress,
			&i.PaymentInitiatedAt,
			&i.FirstSeenAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
			&i.Notes,
			&i.WebhookSent,
			&i.WebhookSentAt,
			&i.EmailSent,
			&i.EmailSentAt,
			&i.TelegramSent,
			&i.TelegramSentAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPaymentsByEmail = `-- name: ListPaymentsByEmail :many
SELECT id, payment_id, address, site, tx_hash, amount_btc, amount_usd, currency, confirmations, required_confirmations, status, email, order_id, user_agent, ip_address, payment_initiated_at, first_seen_at, confirmed_at, completed_at, expires_at, notes, webhook_sent, webhook_sent_at, email_sent, email_sent_at, telegram_sent, telegram_sent_at, created_at, updated_at FROM payments
WHERE email = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPaymentsByEmailParams struct {
	Email  *string `json:"email"`
	Limit  int32   `json:"limit"`
	Offset int32   `json:"offset"`
}

func (q *Queries) ListPaymentsByEmail(ctx context.Context, arg ListPaymentsByEmailParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, ListPaymentsByEmail, arg.Email, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.Address,
			&i.Site,
			&i.TxHash,
			&i.AmountBtc,
			&i.AmountUsd,
			&i.Currency,
			&i.Confirmations,
			&i.RequiredConfirmations,
			&i.Status,
			&i.Email,
			&i.OrderID,
			&i.UserAgent,
			&i.IpAddress,
			&i.PaymentInitiatedAt,
			&i.FirstSeenAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
			&i.Notes,
			&i.WebhookSent,
			&i.WebhookSentAt,
			&i.EmailSent,
			&i.EmailSentAt,
			&i.TelegramSent,
			&i.TelegramSentAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPaymentsBySite = `-- name: ListPaymentsBySite :many
SELECT id, payment_id, address, site, tx_hash, amount_btc, amount_usd, currency, confirmations, required_confirmations, status, email, order_id, user_agent, ip_address, payment_initiated_at, first_seen_at, confirmed_at, completed_at, expires_at, notes, webhook_sent, webhook_sent_at, email_sent, email_sent_at, telegram_sent, telegram_sent_at, created_at, updated_at FROM payments
WHERE site = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPaymentsBySiteParams struct {
	Site   string `json:"site"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListPaymentsBySite(ctx context.Context, arg ListPaymentsBySiteParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, ListPaymentsBySite, arg.Site, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.Address,
			&i.Site,
			&i.TxHash,
			&i.AmountBtc,
			&i.AmountUsd,
			&i.Currency,
			&i.Confirmations,
			&i.RequiredConfirmations,
			&i.Status,
			&i.Email,
			&i.OrderID,
			&i.UserAgent,
			&i.IpAddress,
			&i.PaymentInitiatedAt,
			&i.FirstSeenAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
			&i.Notes,
			&i.WebhookSent,
			&i.WebhookSentAt,
			&i.EmailSent,
			&i.EmailSentAt,
			&i.TelegramSent,
			&i.TelegramSentAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPaymentsByStatus = `-- name: ListPaymentsByStatus :many
SELECT id, payment_id, address, site, tx_hash, amount_btc, amount_usd, currency, confirmations, required_confirmations, status, email, order_id, user_agent, ip_address, payment_initiated_at, first_seen_at, confirmed_at, completed_at, expires_at, notes, webhook_sent, webhook_sent_at, email_sent, email_sent_at, telegram_sent, telegram_sent_at, created_at, updated_at FROM payments
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPaymentsByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListPaymentsByStatus(ctx context.Context, arg ListPaymentsByStatusParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, ListPaymentsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.Address,
			&i.Site,
			&i.TxHash,
			&i.AmountBtc,
			&i.AmountUsd,
			&i.Currency,
			&i.Confirmations,
			&i.RequiredConfirmations,
			&i.Status,
			&i.Email,
			&i.OrderID,
			&i.UserAgent,
			&i.IpAddress,
			&i.PaymentInitiatedAt,
			&i.FirstSeenAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
			&i.Notes,
			&i.WebhookSent,
			&i.WebhookSentAt,
			&i.EmailSent,
			&i.EmailSentAt,
			&i.TelegramSent,
			&i.TelegramSentAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPaymentsWithFilters = `-- name: ListPaymentsWithFilters :many
SELECT id, payment_id, address, site, tx_hash, amount_btc, amount_usd, currency, confirmations, required_confirmations, status, email, order_id, user_agent, ip_address, payment_initiated_at, first_seen_at, confirmed_at, completed_at, expires_at, notes, webhook_sent, webhook_sent_at, email_sent, email_sent_at, telegram_sent, telegram_sent_at, created_at, updated_at FROM payments
WHERE
    ($1::text IS NULL OR site = $1)
    AND ($2::text IS NULL OR status = $2)
    AND (
        $3::text IS NULL
        OR email ILIKE '%' || $3 || '%'
        OR payment_id ILIKE '%' || $3 || '%'
        OR address ILIKE '%' || $3 || '%'
    )
    AND (
        $4::timestamptz IS NULL
        OR created_at >= $4
    )
    AND (
        $5::timestamptz IS NULL
        OR created_at <= $5
    )
ORDER BY created_at DESC
LIMIT $7
OFFSET $6
`

type ListPaymentsWithFiltersParams struct {
	Site      *string            `json:"site"`
	Status    *string            `json:"status"`
	Search    *string            `json:"search"`
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
	Offset    int32              `json:"offset"`
	Limit     int32              `json:"limit"`
}

func (q *Queries) ListPaymentsWithFilters(ctx context.Context, arg ListPaymentsWithFiltersParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, ListPaymentsWithFilters,
		arg.Site,
		arg.Status,
		arg.Search,
		arg.StartDate,
		arg.EndDate,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.Address,
			&i.Site,
			&i.TxHash,
			&i.AmountBtc,
			&i.AmountUsd,
			&i.Currency,
			&i.Confirmations,
			&i.RequiredConfirmations,
			&i.Status,
			&i.Email,
			&i.OrderID,
			&i.UserAgent,
			&i.IpAddress,
			&i.PaymentInitiatedAt,
			&i.FirstSeenAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
			&i.Notes,
			&i.WebhookSent,
			&i.WebhookSentAt,
			&i.EmailSent,
			&i.EmailSentAt,
			&i.TelegramSent,
			&i.TelegramSentAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPendingPayments = `-- name: ListPendingPayments :many
SELECT id, payment_id, address, site, tx_hash, amount_btc, amount_usd, currency, confirmations, required_confirmations, status, email, order_id, user_agent, ip_address, payment_initiated_at, first_seen_at, confirmed_at, completed_at, expires_at, notes, webhook_sent, webhook_sent_at, email_sent, email_sent_at, telegram_sent, telegram_sent_at, created_at, updated_at FROM payments
WHERE status IN ('pending', 'detected', 'confirming')
ORDER BY created_at ASC
`

func (q *Queries) ListPendingPayments(ctx context.Context) ([]Payment, error) {
	rows, err := q.db.Query(ctx, ListPendingPayments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.Address,
			&i.Site,
			&i.TxHash,
			&i.AmountBtc,
			&i.AmountUsd,
			&i.Currency,
			&i.Confirmations,
			&i.RequiredConfirmations,
			&i.Status,
			&i.Email,
			&i.OrderID,
			&i.UserAgent,
			&i.IpAddress,
			&i.PaymentInitiatedAt,
			&i.FirstSeenAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
			&i.Notes,
			&i.WebhookSent,
			&i.WebhookSentAt,
			&i.EmailSent,
			&i.EmailSentAt,
			&i.TelegramSent,
			&i.TelegramSentAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const MarkPaymentExpired = `-- name: MarkPaymentExpired :exec
UPDATE payments
SET
    status = 'expired',
    updated_at = NOW()
WHERE payment_id = $1
`

func (q *Queries) MarkPaymentExpired(ctx context.Context, paymentID string) error {
	_, err := q.db.Exec(ctx, MarkPaymentExpired, paymentID)
	return err
}

const SearchPayments = `-- name: SearchPayments :many
SELECT id, payment_id, address, site, tx_hash, amount_btc, amount_usd, currency, confirmations, required_confirmations, status, email, order_id, user_agent, ip_address, payment_initiated_at, first_seen_at, confirmed_at, completed_at, expires_at, notes, webhook_sent, webhook_sent_at, email_sent, email_sent_at, telegram_sent, telegram_sent_at, created_at, updated_at FROM payments
WHERE site = $1
  AND (
    email ILIKE '%' || $2 || '%'
    OR payment_id ILIKE '%' || $2 || '%'
    OR tx_hash ILIKE '%' || $2 || '%'
    OR address ILIKE '%' || $2 || '%'
  )
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type SearchPaymentsParams struct {
	Site    string  `json:"site"`
	Column2 *string `json:"column_2"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
}

func (q *Queries) SearchPayments(ctx context.Context, arg SearchPaymentsParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, SearchPayments,
		arg.Site,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.Address,
			&i.Site,
			&i.TxHash,
			&i.AmountBtc,
			&i.AmountUsd,
			&i.Currency,
			&i.Confirmations,
			&i.RequiredConfirmations,
			&i.Status,
			&i.Email,
			&i.OrderID,
			&i.UserAgent,
			&i.IpAddress,
			&i.PaymentInitiatedAt,
			&i.FirstSeenAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
			&i.Notes,
			&i.WebhookSent,
			&i.WebhookSentAt,
			&i.EmailSent,
			&i.EmailSentAt,
			&i.TelegramSent,
			&i.TelegramSentAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdatePaymentCompleted = `-- name: UpdatePaymentCompleted :exec
UPDATE payments
SET
    status = 'completed',
    completed_at = NOW(),
    updated_at = NOW()
WHERE payment_id = $1
`

func (q *Queries) UpdatePaymentCompleted(ctx context.Context, paymentID string) error {
	_, err := q.db.Exec(ctx, UpdatePaymentCompleted, paymentID)
	return err
}

const UpdatePaymentConfirmed = `-- name: UpdatePaymentConfirmed :exec
UPDATE payments
SET
    status = 'confirmed',
    confirmations = $2,
    confirmed_at = COALESCE(confirmed_at, NOW()),
    updated_at = NOW()
WHERE payment_id = $1
`

type UpdatePaymentConfirmedParams struct {
	PaymentID     string `json:"payment_id"`
	Confirmations *int32 `json:"confirmations"`
}

func (q *Queries) UpdatePaymentConfirmed(ctx context.Context, arg UpdatePaymentConfirmedParams) error {
	_, err := q.db.Exec(ctx, UpdatePaymentConfirmed, arg.PaymentID, arg.Confirmations)
	return err
}

const UpdatePaymentEmailSent = `-- name: UpdatePaymentEmailSent :exec
UPDATE payments
SET
    email_sent = true,
    email_sent_at = NOW(),
    updated_at = NOW()
WHERE payment_id = $1
`

func (q *Queries) UpdatePaymentEmailSent(ctx context.Context, paymentID string) error {
	_, err := q.db.Exec(ctx, UpdatePaymentEmailSent, paymentID)
	return err
}

const UpdatePaymentTelegramSent = `-- name: UpdatePaymentTelegramSent :exec
UPDATE payments
SET
    telegram_sent = true,
    telegram_sent_at = NOW(),
    updated_at = NOW()
WHERE payment_id = $1
`

func (q *Queries) UpdatePaymentTelegramSent(ctx context.Context, paymentID string) error {
	_, err := q.db.Exec(ctx, UpdatePaymentTelegramSent, paymentID)
	return err
}

const UpdatePaymentTransaction = `-- name: UpdatePaymentTransaction :exec
UPDATE payments
SET
    tx_hash = $2,
    status = $3,
    confirmations = $4,
    first_seen_at = COALESCE(first_seen_at, NOW()),
    updated_at = NOW()
WHERE payment_id = $1
`

type UpdatePaymentTransactionParams struct {
	PaymentID     string  `json:"payment_id"`
	TxHash        *string `json:"tx_hash"`
	Status        string  `json:"status"`
	Confirmations *int32  `json:"confirmations"`
}

func (q *Queries) UpdatePaymentTransaction(ctx context.Context, arg UpdatePaymentTransactionParams) error {
	_, err := q.db.Exec(ctx, UpdatePaymentTransaction,
		arg.PaymentID,
		arg.TxHash,
		arg.Status,
		arg.Confirmations,
	)
	return err
}

const UpdatePaymentWebhookSent = `-- name: UpdatePaymentWebhookSent :exec
UPDATE payments
SET
    webhook_sent = true,
    webhook_sent_at = NOW(),
    updated_at = NOW()
WHERE payment_id = $1
`

func (q *Queries) UpdatePaymentWebhookSent(ctx context.Context, paymentID string) error {
	_, err := q.db.Exec(ctx, UpdatePaymentWebhookSent, paymentID)
	return err
}
