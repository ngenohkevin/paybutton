// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: address_pool.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const AddToQueue = `-- name: AddToQueue :exec
INSERT INTO address_pool_queue (site, address, added_at)
VALUES ($1, $2, NOW())
ON CONFLICT (site, address) DO NOTHING
`

type AddToQueueParams struct {
	Site    string `json:"site"`
	Address string `json:"address"`
}

func (q *Queries) AddToQueue(ctx context.Context, arg AddToQueueParams) error {
	_, err := q.db.Exec(ctx, AddToQueue, arg.Site, arg.Address)
	return err
}

const CountAddressesByStatus = `-- name: CountAddressesByStatus :one
SELECT COUNT(*) as count
FROM address_pool_addresses
WHERE site = $1 AND status = $2
`

type CountAddressesByStatusParams struct {
	Site   string `json:"site"`
	Status string `json:"status"`
}

func (q *Queries) CountAddressesByStatus(ctx context.Context, arg CountAddressesByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, CountAddressesByStatus, arg.Site, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateAddress = `-- name: CreateAddress :one
INSERT INTO address_pool_addresses (
    site, address, address_index, status, email,
    reserved_at, last_checked, payment_count,
    balance_sats, tx_count
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8,
    $9, $10
)
RETURNING id, site, address, address_index, status, email,
          reserved_at, used_at, last_checked, payment_count,
          balance_sats, tx_count, notes, created_at
`

type CreateAddressParams struct {
	Site         string             `json:"site"`
	Address      string             `json:"address"`
	AddressIndex int32              `json:"address_index"`
	Status       string             `json:"status"`
	Email        *string            `json:"email"`
	ReservedAt   pgtype.Timestamptz `json:"reserved_at"`
	LastChecked  time.Time          `json:"last_checked"`
	PaymentCount *int32             `json:"payment_count"`
	BalanceSats  *int64             `json:"balance_sats"`
	TxCount      *int32             `json:"tx_count"`
}

func (q *Queries) CreateAddress(ctx context.Context, arg CreateAddressParams) (AddressPoolAddress, error) {
	row := q.db.QueryRow(ctx, CreateAddress,
		arg.Site,
		arg.Address,
		arg.AddressIndex,
		arg.Status,
		arg.Email,
		arg.ReservedAt,
		arg.LastChecked,
		arg.PaymentCount,
		arg.BalanceSats,
		arg.TxCount,
	)
	var i AddressPoolAddress
	err := row.Scan(
		&i.ID,
		&i.Site,
		&i.Address,
		&i.AddressIndex,
		&i.Status,
		&i.Email,
		&i.ReservedAt,
		&i.UsedAt,
		&i.LastChecked,
		&i.PaymentCount,
		&i.BalanceSats,
		&i.TxCount,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const GetAddress = `-- name: GetAddress :one
SELECT id, site, address, address_index, status, email,
       reserved_at, used_at, last_checked, payment_count,
       balance_sats, tx_count, notes, created_at
FROM address_pool_addresses
WHERE address = $1
`

func (q *Queries) GetAddress(ctx context.Context, address string) (AddressPoolAddress, error) {
	row := q.db.QueryRow(ctx, GetAddress, address)
	var i AddressPoolAddress
	err := row.Scan(
		&i.ID,
		&i.Site,
		&i.Address,
		&i.AddressIndex,
		&i.Status,
		&i.Email,
		&i.ReservedAt,
		&i.UsedAt,
		&i.LastChecked,
		&i.PaymentCount,
		&i.BalanceSats,
		&i.TxCount,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const GetAddressByIndex = `-- name: GetAddressByIndex :one
SELECT id, site, address, address_index, status, email,
       reserved_at, used_at, last_checked, payment_count,
       balance_sats, tx_count, notes, created_at
FROM address_pool_addresses
WHERE site = $1 AND address_index = $2
`

type GetAddressByIndexParams struct {
	Site         string `json:"site"`
	AddressIndex int32  `json:"address_index"`
}

func (q *Queries) GetAddressByIndex(ctx context.Context, arg GetAddressByIndexParams) (AddressPoolAddress, error) {
	row := q.db.QueryRow(ctx, GetAddressByIndex, arg.Site, arg.AddressIndex)
	var i AddressPoolAddress
	err := row.Scan(
		&i.ID,
		&i.Site,
		&i.Address,
		&i.AddressIndex,
		&i.Status,
		&i.Email,
		&i.ReservedAt,
		&i.UsedAt,
		&i.LastChecked,
		&i.PaymentCount,
		&i.BalanceSats,
		&i.TxCount,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const GetAllPoolStats = `-- name: GetAllPoolStats :one
SELECT
    COUNT(*) as total_addresses,
    COUNT(*) FILTER (WHERE status = 'available') as available_count,
    COUNT(*) FILTER (WHERE status = 'reserved') as reserved_count,
    COUNT(*) FILTER (WHERE status = 'used') as used_count,
    COUNT(*) FILTER (WHERE status = 'skipped') as skipped_count,
    COUNT(*) FILTER (WHERE status = 'expired') as expired_count,
    COUNT(*) FILTER (WHERE payment_count > 1) as reused_addresses,
    COUNT(*) FILTER (WHERE status = 'available' AND used_at IS NOT NULL) as recycled_addresses,
    COALESCE(SUM(payment_count), 0) as total_payments_processed
FROM address_pool_addresses
`

type GetAllPoolStatsRow struct {
	TotalAddresses         int64       `json:"total_addresses"`
	AvailableCount         int64       `json:"available_count"`
	ReservedCount          int64       `json:"reserved_count"`
	UsedCount              int64       `json:"used_count"`
	SkippedCount           int64       `json:"skipped_count"`
	ExpiredCount           int64       `json:"expired_count"`
	ReusedAddresses        int64       `json:"reused_addresses"`
	RecycledAddresses      int64       `json:"recycled_addresses"`
	TotalPaymentsProcessed interface{} `json:"total_payments_processed"`
}

// Get aggregated pool statistics across all sites
func (q *Queries) GetAllPoolStats(ctx context.Context) (GetAllPoolStatsRow, error) {
	row := q.db.QueryRow(ctx, GetAllPoolStats)
	var i GetAllPoolStatsRow
	err := row.Scan(
		&i.TotalAddresses,
		&i.AvailableCount,
		&i.ReservedCount,
		&i.UsedCount,
		&i.SkippedCount,
		&i.ExpiredCount,
		&i.ReusedAddresses,
		&i.RecycledAddresses,
		&i.TotalPaymentsProcessed,
	)
	return i, err
}

const GetAllSitePoolStats = `-- name: GetAllSitePoolStats :many
SELECT
    site,
    COUNT(*) as total_addresses,
    COUNT(*) FILTER (WHERE status = 'available') as available_count,
    COUNT(*) FILTER (WHERE status = 'reserved') as reserved_count,
    COUNT(*) FILTER (WHERE status = 'used') as used_count,
    COUNT(*) FILTER (WHERE status = 'skipped') as skipped_count,
    COUNT(*) FILTER (WHERE status = 'expired') as expired_count
FROM address_pool_addresses
GROUP BY site
ORDER BY site
`

type GetAllSitePoolStatsRow struct {
	Site           string `json:"site"`
	TotalAddresses int64  `json:"total_addresses"`
	AvailableCount int64  `json:"available_count"`
	ReservedCount  int64  `json:"reserved_count"`
	UsedCount      int64  `json:"used_count"`
	SkippedCount   int64  `json:"skipped_count"`
	ExpiredCount   int64  `json:"expired_count"`
}

// Get pool statistics grouped by site
func (q *Queries) GetAllSitePoolStats(ctx context.Context) ([]GetAllSitePoolStatsRow, error) {
	rows, err := q.db.Query(ctx, GetAllSitePoolStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllSitePoolStatsRow{}
	for rows.Next() {
		var i GetAllSitePoolStatsRow
		if err := rows.Scan(
			&i.Site,
			&i.TotalAddresses,
			&i.AvailableCount,
			&i.ReservedCount,
			&i.UsedCount,
			&i.SkippedCount,
			&i.ExpiredCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAvailableQueue = `-- name: GetAvailableQueue :many
SELECT q.address, q.added_at
FROM address_pool_queue q
WHERE q.site = $1
ORDER BY q.added_at
`

type GetAvailableQueueRow struct {
	Address string    `json:"address"`
	AddedAt time.Time `json:"added_at"`
}

func (q *Queries) GetAvailableQueue(ctx context.Context, site string) ([]GetAvailableQueueRow, error) {
	rows, err := q.db.Query(ctx, GetAvailableQueue, site)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableQueueRow{}
	for rows.Next() {
		var i GetAvailableQueueRow
		if err := rows.Scan(&i.Address, &i.AddedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetExpiredReservations = `-- name: GetExpiredReservations :many
SELECT id, site, address, address_index, status, email,
       reserved_at, used_at, last_checked, payment_count,
       balance_sats, tx_count, notes, created_at
FROM address_pool_addresses
WHERE status = 'reserved'
  AND reserved_at < NOW() - INTERVAL '72 hours'
ORDER BY reserved_at
`

func (q *Queries) GetExpiredReservations(ctx context.Context) ([]AddressPoolAddress, error) {
	rows, err := q.db.Query(ctx, GetExpiredReservations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AddressPoolAddress{}
	for rows.Next() {
		var i AddressPoolAddress
		if err := rows.Scan(
			&i.ID,
			&i.Site,
			&i.Address,
			&i.AddressIndex,
			&i.Status,
			&i.Email,
			&i.ReservedAt,
			&i.UsedAt,
			&i.LastChecked,
			&i.PaymentCount,
			&i.BalanceSats,
			&i.TxCount,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetExpiredReservationsBySite = `-- name: GetExpiredReservationsBySite :many
SELECT id, site, address, address_index, status, email,
       reserved_at, used_at, last_checked, payment_count,
       balance_sats, tx_count, notes, created_at
FROM address_pool_addresses
WHERE site = $1
  AND status = 'reserved'
  AND reserved_at < NOW() - INTERVAL '72 hours'
ORDER BY reserved_at
`

func (q *Queries) GetExpiredReservationsBySite(ctx context.Context, site string) ([]AddressPoolAddress, error) {
	rows, err := q.db.Query(ctx, GetExpiredReservationsBySite, site)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AddressPoolAddress{}
	for rows.Next() {
		var i AddressPoolAddress
		if err := rows.Scan(
			&i.ID,
			&i.Site,
			&i.Address,
			&i.AddressIndex,
			&i.Status,
			&i.Email,
			&i.ReservedAt,
			&i.UsedAt,
			&i.LastChecked,
			&i.PaymentCount,
			&i.BalanceSats,
			&i.TxCount,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPoolState = `-- name: GetPoolState :one
SELECT site, next_index, last_updated_at, created_at
FROM address_pool_state
WHERE site = $1
`

func (q *Queries) GetPoolState(ctx context.Context, site string) (AddressPoolState, error) {
	row := q.db.QueryRow(ctx, GetPoolState, site)
	var i AddressPoolState
	err := row.Scan(
		&i.Site,
		&i.NextIndex,
		&i.LastUpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const GetPoolStats = `-- name: GetPoolStats :one
SELECT
    COUNT(*) as total_addresses,
    COUNT(*) FILTER (WHERE status = 'available') as available_count,
    COUNT(*) FILTER (WHERE status = 'reserved') as reserved_count,
    COUNT(*) FILTER (WHERE status = 'used') as used_count,
    COUNT(*) FILTER (WHERE status = 'skipped') as skipped_count,
    COUNT(*) FILTER (WHERE status = 'expired') as expired_count
FROM address_pool_addresses
WHERE site = $1
`

type GetPoolStatsRow struct {
	TotalAddresses int64 `json:"total_addresses"`
	AvailableCount int64 `json:"available_count"`
	ReservedCount  int64 `json:"reserved_count"`
	UsedCount      int64 `json:"used_count"`
	SkippedCount   int64 `json:"skipped_count"`
	ExpiredCount   int64 `json:"expired_count"`
}

func (q *Queries) GetPoolStats(ctx context.Context, site string) (GetPoolStatsRow, error) {
	row := q.db.QueryRow(ctx, GetPoolStats, site)
	var i GetPoolStatsRow
	err := row.Scan(
		&i.TotalAddresses,
		&i.AvailableCount,
		&i.ReservedCount,
		&i.UsedCount,
		&i.SkippedCount,
		&i.ExpiredCount,
	)
	return i, err
}

const GetRecentAddressActivity = `-- name: GetRecentAddressActivity :many
SELECT
    a.address,
    a.site,
    a.status,
    a.email,
    a.payment_count,
    a.reserved_at,
    a.used_at,
    a.last_checked,
    a.created_at,
    CASE
        WHEN a.payment_count > 1 THEN 'reused'
        WHEN a.status = 'available' AND a.used_at IS NOT NULL THEN 'recycled'
        WHEN a.status = 'reserved' THEN 'active'
        ELSE 'new'
    END as activity_type
FROM address_pool_addresses a
WHERE a.site = $1
  AND (
      a.reserved_at > NOW() - INTERVAL '24 hours'
      OR a.used_at > NOW() - INTERVAL '24 hours'
      OR a.last_checked > NOW() - INTERVAL '24 hours'
  )
ORDER BY GREATEST(
    COALESCE(a.reserved_at, '1970-01-01'::timestamp),
    COALESCE(a.used_at, '1970-01-01'::timestamp),
    a.last_checked
) DESC
LIMIT 50
`

type GetRecentAddressActivityRow struct {
	Address      string             `json:"address"`
	Site         string             `json:"site"`
	Status       string             `json:"status"`
	Email        *string            `json:"email"`
	PaymentCount *int32             `json:"payment_count"`
	ReservedAt   pgtype.Timestamptz `json:"reserved_at"`
	UsedAt       pgtype.Timestamptz `json:"used_at"`
	LastChecked  time.Time          `json:"last_checked"`
	CreatedAt    time.Time          `json:"created_at"`
	ActivityType string             `json:"activity_type"`
}

// Get recent address activities showing reuse and recycling
func (q *Queries) GetRecentAddressActivity(ctx context.Context, site string) ([]GetRecentAddressActivityRow, error) {
	rows, err := q.db.Query(ctx, GetRecentAddressActivity, site)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentAddressActivityRow{}
	for rows.Next() {
		var i GetRecentAddressActivityRow
		if err := rows.Scan(
			&i.Address,
			&i.Site,
			&i.Status,
			&i.Email,
			&i.PaymentCount,
			&i.ReservedAt,
			&i.UsedAt,
			&i.LastChecked,
			&i.CreatedAt,
			&i.ActivityType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRecyclingStats = `-- name: GetRecyclingStats :one
SELECT
    COUNT(*) FILTER (WHERE payment_count > 1) as reused_addresses,
    COUNT(*) FILTER (WHERE status = 'available' AND used_at IS NOT NULL) as recycled_addresses,
    COUNT(*) FILTER (WHERE reserved_at > NOW() - INTERVAL '24 hours') as recent_reservations,
    COUNT(*) FILTER (WHERE used_at > NOW() - INTERVAL '24 hours') as recent_payments,
    COALESCE(SUM(payment_count), 0) as total_payments_processed,
    COALESCE(MAX(payment_count), 0) as max_reuse_count
FROM address_pool_addresses
WHERE site = $1
`

type GetRecyclingStatsRow struct {
	ReusedAddresses        int64       `json:"reused_addresses"`
	RecycledAddresses      int64       `json:"recycled_addresses"`
	RecentReservations     int64       `json:"recent_reservations"`
	RecentPayments         int64       `json:"recent_payments"`
	TotalPaymentsProcessed interface{} `json:"total_payments_processed"`
	MaxReuseCount          interface{} `json:"max_reuse_count"`
}

// Get statistics about address recycling for dashboard
func (q *Queries) GetRecyclingStats(ctx context.Context, site string) (GetRecyclingStatsRow, error) {
	row := q.db.QueryRow(ctx, GetRecyclingStats, site)
	var i GetRecyclingStatsRow
	err := row.Scan(
		&i.ReusedAddresses,
		&i.RecycledAddresses,
		&i.RecentReservations,
		&i.RecentPayments,
		&i.TotalPaymentsProcessed,
		&i.MaxReuseCount,
	)
	return i, err
}

const ListAddressesBySite = `-- name: ListAddressesBySite :many
SELECT id, site, address, address_index, status, email,
       reserved_at, used_at, last_checked, payment_count,
       balance_sats, tx_count, notes, created_at
FROM address_pool_addresses
WHERE site = $1
ORDER BY address_index
`

func (q *Queries) ListAddressesBySite(ctx context.Context, site string) ([]AddressPoolAddress, error) {
	rows, err := q.db.Query(ctx, ListAddressesBySite, site)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AddressPoolAddress{}
	for rows.Next() {
		var i AddressPoolAddress
		if err := rows.Scan(
			&i.ID,
			&i.Site,
			&i.Address,
			&i.AddressIndex,
			&i.Status,
			&i.Email,
			&i.ReservedAt,
			&i.UsedAt,
			&i.LastChecked,
			&i.PaymentCount,
			&i.BalanceSats,
			&i.TxCount,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAddressesBySiteAndStatus = `-- name: ListAddressesBySiteAndStatus :many
SELECT id, site, address, address_index, status, email,
       reserved_at, used_at, last_checked, payment_count,
       balance_sats, tx_count, notes, created_at
FROM address_pool_addresses
WHERE site = $1 AND status = $2
ORDER BY address_index
`

type ListAddressesBySiteAndStatusParams struct {
	Site   string `json:"site"`
	Status string `json:"status"`
}

func (q *Queries) ListAddressesBySiteAndStatus(ctx context.Context, arg ListAddressesBySiteAndStatusParams) ([]AddressPoolAddress, error) {
	rows, err := q.db.Query(ctx, ListAddressesBySiteAndStatus, arg.Site, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AddressPoolAddress{}
	for rows.Next() {
		var i AddressPoolAddress
		if err := rows.Scan(
			&i.ID,
			&i.Site,
			&i.Address,
			&i.AddressIndex,
			&i.Status,
			&i.Email,
			&i.ReservedAt,
			&i.UsedAt,
			&i.LastChecked,
			&i.PaymentCount,
			&i.BalanceSats,
			&i.TxCount,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const MarkAddressUsed = `-- name: MarkAddressUsed :exec
UPDATE address_pool_addresses
SET status = 'used',
    used_at = NOW(),
    payment_count = payment_count + 1,
    last_checked = NOW()
WHERE address = $1
`

func (q *Queries) MarkAddressUsed(ctx context.Context, address string) error {
	_, err := q.db.Exec(ctx, MarkAddressUsed, address)
	return err
}

const MarkAddressUsedWithSite = `-- name: MarkAddressUsedWithSite :exec
UPDATE address_pool_addresses
SET site = $2,
    status = 'used',
    used_at = NOW(),
    payment_count = payment_count + 1,
    last_checked = NOW()
WHERE address = $1
`

type MarkAddressUsedWithSiteParams struct {
	Address string `json:"address"`
	Site    string `json:"site"`
}

func (q *Queries) MarkAddressUsedWithSite(ctx context.Context, arg MarkAddressUsedWithSiteParams) error {
	_, err := q.db.Exec(ctx, MarkAddressUsedWithSite, arg.Address, arg.Site)
	return err
}

const RemoveFromQueue = `-- name: RemoveFromQueue :exec
DELETE FROM address_pool_queue
WHERE site = $1 AND address = $2
`

type RemoveFromQueueParams struct {
	Site    string `json:"site"`
	Address string `json:"address"`
}

func (q *Queries) RemoveFromQueue(ctx context.Context, arg RemoveFromQueueParams) error {
	_, err := q.db.Exec(ctx, RemoveFromQueue, arg.Site, arg.Address)
	return err
}

const UpdateAddressBalance = `-- name: UpdateAddressBalance :exec
UPDATE address_pool_addresses
SET balance_sats = $2,
    tx_count = $3,
    last_checked = NOW()
WHERE address = $1
`

type UpdateAddressBalanceParams struct {
	Address     string `json:"address"`
	BalanceSats *int64 `json:"balance_sats"`
	TxCount     *int32 `json:"tx_count"`
}

func (q *Queries) UpdateAddressBalance(ctx context.Context, arg UpdateAddressBalanceParams) error {
	_, err := q.db.Exec(ctx, UpdateAddressBalance, arg.Address, arg.BalanceSats, arg.TxCount)
	return err
}

const UpdateAddressReservation = `-- name: UpdateAddressReservation :exec
UPDATE address_pool_addresses
SET status = 'reserved',
    email = $2,
    reserved_at = $3,
    last_checked = NOW()
WHERE address = $1
`

type UpdateAddressReservationParams struct {
	Address    string             `json:"address"`
	Email      *string            `json:"email"`
	ReservedAt pgtype.Timestamptz `json:"reserved_at"`
}

func (q *Queries) UpdateAddressReservation(ctx context.Context, arg UpdateAddressReservationParams) error {
	_, err := q.db.Exec(ctx, UpdateAddressReservation, arg.Address, arg.Email, arg.ReservedAt)
	return err
}

const UpdateAddressSiteAndReservation = `-- name: UpdateAddressSiteAndReservation :exec
UPDATE address_pool_addresses
SET site = $2,
    status = 'reserved',
    email = $3,
    reserved_at = $4,
    last_checked = NOW()
WHERE address = $1
`

type UpdateAddressSiteAndReservationParams struct {
	Address    string             `json:"address"`
	Site       string             `json:"site"`
	Email      *string            `json:"email"`
	ReservedAt pgtype.Timestamptz `json:"reserved_at"`
}

func (q *Queries) UpdateAddressSiteAndReservation(ctx context.Context, arg UpdateAddressSiteAndReservationParams) error {
	_, err := q.db.Exec(ctx, UpdateAddressSiteAndReservation,
		arg.Address,
		arg.Site,
		arg.Email,
		arg.ReservedAt,
	)
	return err
}

const UpdateAddressStatus = `-- name: UpdateAddressStatus :exec
UPDATE address_pool_addresses
SET status = $2,
    last_checked = NOW()
WHERE address = $1
`

type UpdateAddressStatusParams struct {
	Address string `json:"address"`
	Status  string `json:"status"`
}

func (q *Queries) UpdateAddressStatus(ctx context.Context, arg UpdateAddressStatusParams) error {
	_, err := q.db.Exec(ctx, UpdateAddressStatus, arg.Address, arg.Status)
	return err
}

const UpsertPoolState = `-- name: UpsertPoolState :exec
INSERT INTO address_pool_state (site, next_index, last_updated_at)
VALUES ($1, $2, NOW())
ON CONFLICT (site)
DO UPDATE SET
    next_index = EXCLUDED.next_index,
    last_updated_at = NOW()
`

type UpsertPoolStateParams struct {
	Site      string `json:"site"`
	NextIndex int32  `json:"next_index"`
}

func (q *Queries) UpsertPoolState(ctx context.Context, arg UpsertPoolStateParams) error {
	_, err := q.db.Exec(ctx, UpsertPoolState, arg.Site, arg.NextIndex)
	return err
}
